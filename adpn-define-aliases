#!/bin/bash
#
# adpn-define-aliases: some basic subroutines used across many of the adpn suite of scripts
#
# @version 2019.1016

PATH=${SCRIPTDIR}:${PATH}
CONFFILE="${SCRIPTDIR}/${SCRIPT}.defaults.conf"
JSONCONFFILE="${SCRIPTDIR}/adpnet.json"

# adpnprop: retrieve and echo a property from the adpnet.json config file
# example: FOOBAR=$( adpnprop "${KEY}" )
#
# @param string key name to retrieve from JSON config file
# @return int exit code from adpn-json.py (0=success, 1=key not found)
#
# @version 2021.0406
adpnprop() {
	local key="${1}"
	local switch=""	
	local value=""
	declare -a adpnprop_switches=()
	declare -A adpnprop_params=()
	
	while [[ "$#" -gt 0 && "${1}" =~ ^--([A-Za-z_0-9][^=]*)(=(.*))?$ ]] ; do
		switch="${BASH_REMATCH[1]}"
		value="${BASH_REMATCH[3]}"
		if [[ -z "${BASH_REMATCH[2]}" ]] ; then
			value="${switch}"
		fi
		adpnprop_switches+=( "${1}" )
		adpnprop_params["${switch}"]="${value}"
		shift

		key="${1}"
	done
	
	JSON="{}"
	if [[ -r "${JSONCONFFILE}" ]] ; then
		JSON=$( cat "${JSONCONFFILE}" )
	fi
	
	if [[ -z "${key}" ]] ; then
		REPLY=$( echo "${JSON}" | adpn-json.py --output=text/plain "${adpnprop_switches[@]}")
		JSONEXIT=$?
	else
		REPLY=$( echo "${JSON}" | adpn-json.py --key="${key}" "${adpnprop_switches[@]}")
		JSONEXIT=$?
	fi
	printf "%s" "${REPLY}" 
	return "${JSONEXIT}"
}

function pluginprop() {
	local txt="${1}" ; shift
	local key="${1}" ; shift
	local regex=""
	
	if [[ -z "${key}" ]] ; then
		regex=".*"
	else
		regex="^${key}\t"
	fi
	
	cat "${txt}" | grep -P "${regex}" | lockss-plugin-props-print-parameter.py "$@"
	return $?
}

declare -A _LINESWITCH=()

function adpn_command_line() {
	shopt -s lastpipe

	cat "$@" 2>/dev/null | while IFS="" read -r SWITCH ; do
		
		if [[ "${SWITCH}" =~ ^--([A-Za-z_0-9][^=]*)(=(.*))?$ ]] ; then
			KEY="${BASH_REMATCH[1]}"
			VALUE="${BASH_REMATCH[3]}"
			if [[ -z "${BASH_REMATCH[2]}" ]] ; then
				VALUE="$KEY"
			fi
			_PARAM[$KEY]="${VALUE}"
			_LINESWITCH[$KEY]="${SWITCH}"

		elif [[ ! -z "${SWITCH}" ]] ; then
			_ARGV+=("${SWITCH}")
			
		fi
		
	done
	
}

# adpn_check_dependency: check a list of dependencies; if at least one fails,
# maybe output instructions or suggestions about how to resolve the failure
#
# @version 2021.0407
function adpn_check_dependencies () {

	local result=0
	
	declare -a acds_argv=("${0}")
	declare -A acds_switches=()
	declare -A acds_params=()

	while [[ "$#" -gt 0 ]] ; do
		local param="${1}" ; shift

		if [[ "${param}" =~ ^--([A-Za-z_0-9][^=]*)(=(.*))?$ ]] ; then
			local switch="${BASH_REMATCH[1]}"
			local value="${BASH_REMATCH[3]}"
			if [[ -z "${BASH_REMATCH[2]}" ]] ; then
				value="${switch}"
			fi
			acds_switches["${switch}"]="${param}"
			acds_params["${switch}"]="${value}"
		else
			acds_argv+=("${param}")
		fi
	done
	
	local file="${acds_argv[1]}"
	if [[ -z "${file}" ]] ; then
		file=-
	fi
	
	IFS=""
	shopt -s lastpipe # allow export of variables from the last command in a pipeline
	
	cat "${file}" | while read -r LINE ; do
		local dependency=$( printf "%s\n" "${LINE}" | cut --field=1 )
		local description=$( printf "%s\n" "${LINE}" | cut --field=2 --only-delimited )
		local instruction=""
		
		local i=3
		local instruction_option=$( printf "%s\n" "${LINE}" | cut --field=${i} --only-delimited )
		while [[ -n "${instruction_option}" ]] ; do
			local packman=$( printf "%s\n" "${instruction_option}" | cut --field=1 --delimiter=" " )
			which "${packman}" 2>/dev/null >/dev/null && instruction="${instruction_option}"
			i=$(( i + 1 ))
			instruction_option=$( printf "%s\n" "${LINE}" | cut --field=${i} --only-delimited )
		done

		local r=0
		adpn_check_dependency "${dependency}" "${description}" "${instruction}" ${acds_switches[interactive]} ; r="$?"
		if [[ "${r}" -gt "${result}" ]] ; then
			result="${r}"
		fi
		
	done
	return "${result}"
}

# adpn_check_dependency: check for a dependency; in case of failure, maybe
# output instructions or suggestions about how to resolve the failure
#
# @version 2021.0407
function adpn_check_dependency () {

	declare -a acd_argv=("${0}")
	declare -a acd_switches=()
	declare -A acd_params=()
	
	while [[ "$#" -gt 0 ]] ; do
		local param="${1}" ; shift

		if [[ "${param}" =~ ^--([A-Za-z_0-9][^=]*)(=(.*))?$ ]] ; then
			local switch="${BASH_REMATCH[1]}"
			local value="${BASH_REMATCH[3]}"
			if [[ -z "${BASH_REMATCH[2]}" ]] ; then
				value="${switch}"
			fi
			acd_switches+=( "${param}" )
			acd_params["${switch}"]="${value}"
		else
			acd_argv+=("${param}")
		fi
	done

	local dependency="${acd_argv[1]}"
	local description="${acd_argv[2]}" ; shift
	local instruction="${acd_argv[3]}" ; shift

	local result=0

	local dep_type=$( printf "%s" "${dependency}" | cut --field=1 --delimiter=":" --only-delimited )
	local dep_name=$( printf "%s" "${dependency}" | cut --field=2 --delimiter=":" )
	
	if [[ -n "${dependency}" ]] ; then
	
		case "${dep_type}" in
		"")
			which "${dep_name}" > /dev/null || result="$?"
			;;
		"python")
			local PYTHON_IMPORT=$( printf "import %s" "${dep_name}" )
			python3 -c "${PYTHON_IMPORT}" 2>/dev/null || result="$?"
			;;
		*)
			;;
		esac
	fi
	
	if [[ "${result}" -gt 0 ]] ; then
		printf "Dependency Failure: %s." "${dep_name}" 1>&2
		if [[ -n "${description}" ]] ; then
			local s_desc=$( printf "${description}" "${dep_name}" )
			printf " This script requires the %s." "${s_desc}" 1>&2
		fi
		printf "\n" 1>&2
		
		if [[ -n "${instruction}" ]] ; then
			if [[ -n "${acd_params[interactive]}" ]] ; then
				read -n 1 -p "Install using command (${instruction}) (y/N)? " INST_YN < /dev/tty
				INST_YN=$( printf "%s" "${INST_YN}" | tr "[:lower:]" "[:upper:]" )
				printf "\n"
			else
				INST_YN="N"
			fi
			
			if [[ "Y" == "${INST_YN}" ]] ; then
				sudo su -c "${instruction}" < /dev/tty ; result="$?"
			else
				printf "To resolve this failure, use: %s\n" "${instruction}" 1>&2
			fi
		fi
		
	fi

	return "${result}"
}

# adpn_help_notes: get help or usage notes included in the script comments,
# marked off with a @package or @method docblock directive
#
# @param string path to the script file; packages should be named the same
#               as the command base name (e.g. script adpn = @package adpn)
# @param string optional, method name
# @param string optional, context of call, used in error messages
# @return int exit code, 0=success; 255=no help notes for package or method
#
# @version 2021.0407

function adpn_help_notes () {
	local scriptpath="${1}" ; shift
	local method="${1}" ; shift
	local context="${1}" ; shift

	if [[ -n "${context}" ]] ; then
		context=" ${context}"
	fi
	
	local package=$(basename "${scriptpath}")
	local directive="[@]package ${package}\b"
	local HELPNOTES=""
	
	if [[ ! -z "${method}" ]] ; then
		directive="[@]method ${package} ${method}\b"
	fi
	
	HELPNOTES=$( sed --quiet "/^[#] ${directive}/,/^[#] @version/p" ${scriptpath} )
	
	if [ -z "${HELPNOTES}" ] ; then
		echo "[${package}${context}] '${method}' help notes not yet implemented." 1>&2
		EXITCODE=255
	else 
		echo "${HELPNOTES}" | grep "^[#]" | grep -v "^[#] [@]" | sed "s/^[#] *//"
		EXITCODE=0
	fi
	
	return "${EXITCODE}"
}

function adpn_setting() {
	local switch="${1}"
	local prop="${2}"
	
	if [[ -z "${prop}" ]] ; then
		prop="${1}"
	fi
	
	if [[ ! -z "${_PARAM[$switch]}" ]] ; then
		printf "%s" "${_PARAM[$switch]}"
	else
		adpnprop "${prop}"
	fi
}

function echo_header() {
	local title="${1}"
	local underline="${2}"
	
	UPTITLE=$( echo "${title}" | tr "[:lower:]" "[:upper:]" )
	UNDERLINE=$( echo "${UPTITLE}" | sed "s/./${underline}/g" )
	
	echo ""
	echo "${UPTITLE}"
	echo "${UNDERLINE}"
}

export ADPN_JSON_PACKET_REGEX="$( adpn-json.py --regex )"

# adpn_get_json_packet: filter an input stream for JSON packets, based on regex
# for a JSON packet or prolog from adpn-json.py 
# example: FOOBAR=$( adpnprop "${KEY}" )
#
# @param string file name of input to filter for JSON packets; "-" for stdin/pipeline
# @return int exit code from grep (0=success, 1=nothing found)
#
# @version 2021.0407

function adpn_get_json_packet() {
	local file="${1}"
	local packet=""
	local result=0

	if [[ -z "${file}" ]] ; then 
		file="-"
	fi
	
	packet=$( grep -P $ADPN_JSON_PACKET_REGEX "${file}" )
	result="$?"
	if [[ -n "${packet}" ]] ; then
		printf "%s\n" "${packet}"
	fi
	return "${result}"
}

# rawurlencode: Encode a command-line parameter to URL (%hex) style encoding and output
# example: FOOBAR=$( rawurlencode "${DATA}" )
# uses code from @Orwellophile at https://stackoverflow.com/questions/296536/how-to-urlencode-data-for-curl-command
# @version 2019.0807
rawurlencode() {
  local string="${1}"
  local strlen=${#string}
  local encoded=""
  local pos c o
  local level="${2}"
  
  for (( pos=0 ; pos<strlen ; pos++ )); do
     c=${string:$pos:1}
     case "$c" in
        [-_a-zA-Z0-9] ) 	o="${c}" ;;
        [.~] )          	[[ "${level}" -ge 2 ]] && printf -v o '%%%02X' "'$c" || o="${c}" ;;
        * )             	printf -v o '%%%02X' "'$c"
     esac
     encoded+="${o}"
  done
  echo "${encoded}"    # You can either set a return variable (FASTER) 
  REPLY="${encoded}"   #+or echo the result (EASIER)... or both... :p
}

# urldecode: Decodes a command-line parameter from URL (%hex) style encoding to plain text
# one-liner solution provided by @guest and @netdesignate at https://stackoverflow.com/a/37840948
function urldecode() { : "${*//+/ }"; echo -e "${_//%/\\x}"; }

# join_by: Joins a list of parameters using a delimiter string
# one-liner solution provided by @Nicholas Sushkin at https://stackoverflow.com/a/17841619
function join_by { local d=${1-} f=${2-}; if shift 2; then printf %s "$f" "${@/#/$d}"; fi; }