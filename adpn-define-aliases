#!/bin/bash
#
# adpn-define-aliases: some basic subroutines used across many of the adpn suite of scripts
#
# @version 2021.0807-1244

PATH="${SCRIPTDIR}:${PATH}"
CONFFILE="${SCRIPTDIR}/${SCRIPT}.defaults.conf"
JSONCONFFILE="${SCRIPTDIR}/adpnet.json"

SCRIPT="$(basename "${SCRIPTPATH}")"
ME="${SCRIPTPATH}"
ADPN="$( readlink --canonicalize "${SCRIPTDIR}/adpn" )"

__ALIASFILE__="$( basename "${BASH_SOURCE}" )"

# adpn_parameter_from: retrieve and echo a property that may be found in one of several possible sources for parameter data, including
# command-line switches, JSON configuration files, live JSON data, user console input, and fall-back defaults.
# example: FOOBAR=$( adpn_parameter_from "--foo" "--bar" ".baz" "<FOO [bar]: " )
#
# --SWITCH: accept a parameter from the command-line switch named SWITCH
# .PROPERTY: accept a parameter from the key-value pair in the data provided by the standard configuration JSON file (typically adpnet.json)
# .PROPERTY<{JSON DATA}: accept a parameter from the key-value pair in the JSON DATA provided
# <PROMPT: accept a parameter interactively from user input, using the text in PROMPT as a prompt
# TEXT: use the literal text provided as a default value if previous sources have failed
# \TEXT: use the literal text provided as a default value if previous sources have failed; the backslash allows for text beginning with special characters like "--", ".", "<" or "\"
#
# @version 2021.0730

function adpn_parameter_from() {
	RESULT="" ; EXITCODE=2

	adpn_debug 500 "${__ALIASFILE__}:${LINENO}" "%s(%s)" "adpn_parameter_from" "$( join_by ', ' "${@:1}" )"
	while [[ "$#" -gt 0 && "${EXITCODE}" -gt 0 ]] ; do
		local source="${1}" ; shift
		adpn_debug 600 "${__ALIASFILE__}:${LINENO}" "source='%s'" "$source" 

		if [[ "${source}" =~ ^(--|!!)(.*)$ ]] ; then
			KEY="${BASH_REMATCH[2]}"
			# in a civilized version of batch we could use test -v
			# but we're not always in civilized places...
			# technique from <https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash/13864829#13864829>
			if [[ -n "${_PARAM[$KEY]+SET}" ]] ;then
				RESULT="${_PARAM[$KEY]}" ; EXITCODE=0
			fi
		elif [[ "${source}" =~ ^[.]([^\<]+)([\<](.*))?$ ]] ; then
			KEY="${BASH_REMATCH[1]}"
			JSON="${BASH_REMATCH[3]}"
			if [[ "${JSON}" == '(adpn stash)' ]] ; then
				RESULT="$( adpn stash get --output=application/json | adpn-json.py --output=text/plain --key="${KEY}" )" ; EXITCODE="$?"
			elif [[ -n "${JSON}" ]] ; then
				RESULT="$( printf "%s" "${JSON}" | adpn-json.py --output=text/plain --key="${KEY}" )" ; EXITCODE="$?"
			else
				RESULT="$( adpnprop "${KEY}" )" ; EXITCODE="$?"
			fi
		elif [[ "${source}" =~ ^[\<](.*)$ ]] ; then
			read -p "${BASH_REMATCH[1]}" RESULT ; EXITCODE="$?"
			[[ -z "${RESULT}" ]] && EXITCODE=1
		elif [[ "${source}" =~ ^\\(.*)$ ]] ; then
			RESULT="${BASH_REMATCH[1]}" ; EXITCODE=0
		else 
			RESULT="${source}" ; EXITCODE=0
		fi
		
	done
	
	printf "%s" "${RESULT}"
	return "${EXITCODE}"
}

function adpn_get_user_email () {
	adpn_get_email_from ".user/email" ".user/realname"
}

function adpn_get_email_from () {
	local email_from="${1}" ; shift
	local realname_from="${1}" ; shift
	
	local email="$( adpn_parameter_from "${email_from}" )"
	local realname="$( adpn_parameter_from "${realname_from}" )"
	
	[[ -n "${realname}" ]] && email=$( printf "%s <%s>" "${realname}" "${email}" )
	
	printf "%s" "${email}"
}

# adpnprop: retrieve and echo a property from the adpnet.json config file
# example: FOOBAR=$( adpnprop "${KEY}" )
#
# @param string key name to retrieve from JSON config file
# @return int exit code from adpn-json.py (0=success, 1=key not found)
#
# @version 2021.0406
adpnprop() {
	local key="${1}"
	local switch=""	
	local value=""
	declare -a adpnprop_switches=()
	declare -A adpnprop_params=()
	
	while [[ "$#" -gt 0 && "${1}" =~ ^--([A-Za-z_0-9][^=]*)(=(.*))?$ ]] ; do
		switch="${BASH_REMATCH[1]}"
		value="${BASH_REMATCH[3]}"
		if [[ -z "${BASH_REMATCH[2]}" ]] ; then
			value="${switch}"
		fi
		adpnprop_switches+=( "${1}" )
		adpnprop_params["${switch}"]="${value}"
		shift

		key="${1}"
	done
	
	JSON="{}"
	if [[ -r "${JSONCONFFILE}" ]] ; then
		JSON=$( cat "${JSONCONFFILE}" )
	fi
	
	if [[ -z "${key}" ]] ; then
		REPLY=$( echo "${JSON}" | adpn-json.py --output=text/plain "${adpnprop_switches[@]}")
		JSONEXIT=$?
	else
		REPLY=$( echo "${JSON}" | adpn-json.py --key="${key}" "${adpnprop_switches[@]}")
		JSONEXIT=$?
	fi
	printf "%s" "${REPLY}" 
	return "${JSONEXIT}"
}

# pluginprop: retrieve and echo a property from the text output of adpn-ingest-test, adpn-plugin-info
# and related tools that plug AU data into LOCKSS plugin parameters.
# 
# @param string txt tab-separated value text containing Key <tab> Text values
# @param string key name of field to retrieve from plugin data
# @return int exit code from lockss-plugin-props-print-parameter.py
function pluginprop() {
	local txt="${1}" ; shift
	local key="${1}" ; shift
	local regex=""
	
	if [[ -z "${key}" ]] ; then
		regex=".*"
	else
		regex="^${key}\t"
	fi
	
	cat "${txt}" | grep -P "${regex}" | lockss-plugin-props-print-parameter.py "$@"
	return $?
}

function adpn_getpassword_from() {
	
	RESULT="" ; EXITCODE=2
	KDBX_SCHEME="keepass"
	while [[ "$#" -gt 0 && "${EXITCODE}" -gt 0 ]] ; do
		local source="${1}" ; shift
		if [[ "${source}" =~ ^${KDBX_SCHEME}:/*(/([^/]+)+) ]] ; then
			local FILENAME="$( printf "%s" "${source}" | sed -E 's/^[^:]+[:]\/+/\//' | sed -E 's/[?].*$//' )"
			FILENAME="$( basename "${FILENAME}" )"
			MD5=$( printf "%s" "${FILENAME}" | md5sum | sed -E 's/\s+.*$//g' )
			PASSKEY="$( printf "AGK-Pass-%s" "${MD5}" )"
			PASSPHRASE="$( adpn stash get "${PASSKEY}" )"

			local -a AGK_SW=( "adpn-get-keepass.py" "--single" )
			AGK_SW+=("${source}")
			if [[ -n "${PASSPHRASE}" ]] ; then
				adpn_debug 500,adpn,stash "${LINENO}" "adpn_get_password_from: Using stashed passphrase: %s" "$( obscure_password "${PASSPHRASE}" )"
				RESULT="$( printf "%s" "${PASSPHRASE}" | "${AGK_SW[@]}" )"
			else 
				adpn_debug 500,adpn,stash "${LINENO}" "adpn_get_password_from: Using interactive request"
				AGK_SW+=( "--interactive" )
				AGK_SW+=( "--stash=adpn stash post ${PASSKEY}" )
				[[ -n "${DDBG}" ]] && AGK_SW+=( "${DDBG}" )
				RESULT="$(  "${AGK_SW[@]}" )"
			fi
			EXITCODE="$?"
		elif [[ "${source}" =~ ^[\<](.*)$ ]] ; then
			IFS='' read -s -p "${BASH_REMATCH[1]}" RESULT 1>&2 ; EXITCODE="$?"
			[[ -z "${RESULT}" ]] && EXITCODE=1
		elif [[ "${source}" =~ ^\\(.*)$ ]] ; then
			RESULT="${BASH_REMATCH[1]}" ; EXITCODE=0
		else 
			RESULT="${source}" ; EXITCODE=0
		fi
	done
	
	printf "%s" "${RESULT}"
	return "${EXITCODE}"
}

declare -a _ARGV=()
declare -A _PARAM=()
declare -A _SWITCHES=()

function adpn_command_line() {
	shopt -s lastpipe
	
	local switches_on=1
	
	[[ "${#_ARGV}" -eq 0 ]] && _ARGV+=( "$0" )
	
	cat "$@" 2>/dev/null | while IFS="" read -r SWITCH ; do
		if [[ "${switches_on}" -gt 0 && "${SWITCH}" =~ ^--$ ]] ; then
			switches_on=0
		elif [[ "${switches_on}" -gt 0 && "${SWITCH}" =~ ^--([A-Za-z_0-9][^=]*)(=(.*))?$ ]] ; then
			local KEY="${BASH_REMATCH[1]}"
			local VALUE="${BASH_REMATCH[3]}"
			if [[ -z "${BASH_REMATCH[2]}" ]] ; then
				VALUE="$KEY"
			fi
			_PARAM[$KEY]="${VALUE}"
			_SWITCHES[$KEY]="${SWITCH}"

		elif [[ ! -z "${SWITCH}" ]] ; then
			_ARGV+=("${SWITCH}")
			
		fi
		
	done
	
}

declare -x DDBG DDBGLEVEL
declare -a DBGTAGS=()
function adpn_set_display_settings() {
	VV="${_SWITCHES[verbose]}"
	QQ="${_SWITCHES[quiet]}"
	V="${_SWITCHES[verbose]}"
	Q=""

	[[ -n "${DDBG}" ]] && DBG="${DDBG}" || DBG="${_SWITCHES[debug]}"
	DBGLEVEL="${_PARAM[debug]}"
	if [[ "${DBGLEVEL}" =~ ^[0-9]+([,]|$) ]] ; then
		DBGLEVEL="${DBGLEVEL}"
	elif [[ -n "${DBGLEVEL}" ]] ; then
		DBGLEVEL="1,${DBGLEVEL}"
	fi
	
	DBGTAGS=( $( printf "%s" "${DBGLEVEL}" | tr "," "\n" | tail -n +2 ) )
	DBGLEVEL=$( printf "%s" "${DBGLEVEL}" | cut --delimiter="," --field=1 )
	
	if [[ "${DBGLEVEL}" -gt 1 ]] ; then
		local -a d_levels_down=( $(( DBGLEVEL - 1 )) "${DBGTAGS[@]}" )
		DDBGLEVEL=$( join_by "," "${d_levels_down[@]}" )
		DDBG="--debug=${DDBGLEVEL}"
	else
		DDBGLEVEL=""
		DDBG=""
	fi

	if [[ -z "${_PARAM[verbose]}" ]] ; then
		Q="--quiet"
	fi
	if [[ -n "${QQ}" ]] ; then
		Q="--quiet"
	fi
	
	local script_cmd=$( printf "%s" "${SCRIPT} ${CMD}" | sed -E 's/\s+$//' )
	SCRIPT_CMD_NAME=$( adpn_parameter_from "--context" "\\${script_cmd}" )
}

# adpn_check_dependency: check a list of dependencies; if at least one fails,
# maybe output instructions or suggestions about how to resolve the failure
#
# @version 2021.0407
function adpn_check_dependencies () {

	local result=0
	
	declare -a acds_argv=("${0}")
	declare -A acds_switches=()
	declare -A acds_params=()

	while [[ "$#" -gt 0 ]] ; do
		local param="${1}" ; shift

		if [[ "${param}" =~ ^--([A-Za-z_0-9][^=]*)(=(.*))?$ ]] ; then
			local switch="${BASH_REMATCH[1]}"
			local value="${BASH_REMATCH[3]}"
			if [[ -z "${BASH_REMATCH[2]}" ]] ; then
				value="${switch}"
			fi
			acds_switches["${switch}"]="${param}"
			acds_params["${switch}"]="${value}"
		else
			acds_argv+=("${param}")
		fi
	done
	
	adpn_debug 10 "${__ALIASFILE__}:${LINENO}" "%s(%s) %s" "adpn_check_dependencies" "$( join_by ", " "${acds_argv[@]:1}" )" "$( join_by " " "${acds_switches[@]}" )"

	local file="${acds_argv[1]}"
	[[ -z "${file}" ]] && file=- # default to stdin
	
	local my_feature="${acds_params[for]}"
	[[ -z "${my_feature}" ]] && my_feature="any"
	local -a my_features=()
	IFS=$( printf ", " ) read -ra my_features<<<"${my_feature}"
	
	IFS=""
	shopt -s lastpipe # allow export of variables from the last command in a pipeline
	
	cat "${file}" | while read -r LINE ; do
		local CONTENT="$( printf "%s\n" "${LINE}" | cut --delimiter="#" --field=1 )"
		local CONTEXT="$( printf "%s\n" "${LINE}" | cut --delimiter="#" --only-delimited --fields=2- )"
		
		local -a CONTEXTS=()
		IFS=$( printf "# \t\n" ) read -ra CONTEXTS<<<"${CONTEXT}"
		[[ "${#CONTEXTS[@]}" -gt 0 ]] && CONTEXTS+=( "any" )
		[[ "${#CONTEXTS[@]}" -gt 0 ]] || CONTEXTS+=( ".*" )
		
		local dependency=$( printf "%s\n" "${CONTENT}" | cut --field=1 )
		local description=$( printf "%s\n" "${CONTENT}" | cut --field=2 --only-delimited )
		local instruction=""
		
		local i=3
		local instruction_option=$( printf "%s\n" "${CONTENT}" | cut --field=${i} --only-delimited )
		while [[ -n "${instruction_option}" ]] ; do
			local packman=$( printf "%s\n" "${instruction_option}" | cut --field=1 --delimiter=" " )
			which "${packman}" 2>/dev/null >/dev/null && instruction="${instruction_option}"
			i=$(( i + 1 ))
			instruction_option=$( printf "%s\n" "${CONTENT}" | cut --field=${i} --only-delimited )
		done
		
		local r=-1
		for FEATURE in "${my_features[@]}" ; do
			local CHECK="$( join_by "|" "${CONTEXTS[@]}" )"
			if [[ "${r}" -lt 0 ]] ; then
				if [[ "${FEATURE}" =~ ^(${CHECK})$ ]] ; then
					if [[ -n "${dependency}" ]] ; then
						local -a acd_sw=( "${dependency}" "${description}" "${instruction}" )
						[[ -n "${acds_switches[interactive]}" ]] && acd_sw+=("${acds_switches[interactive]}" )
						adpn_check_dependency "${acd_sw[@]}" ; r="$?"
						if [[ "${r}" -gt "${result}" ]] ; then
							result="${r}"
						fi
					fi
				fi
			fi
		done
		
	done
	return "${result}"
}

# adpn_check_dependency: check for a dependency; in case of failure, maybe
# output instructions or suggestions about how to resolve the failure
#
# @version 2021.0407
function adpn_check_dependency () {

	local -a acd_argv=("${0}")
	local -a acd_switches=()
	local -A acd_params=()
	
	while [[ "$#" -gt 0 ]] ; do
		local param="${1}" ; shift

		if [[ "${param}" =~ ^--([A-Za-z_0-9][^=]*)(=(.*))?$ ]] ; then
			local switch="${BASH_REMATCH[1]}"
			local value="${BASH_REMATCH[3]}"
			if [[ -z "${BASH_REMATCH[2]}" ]] ; then
				value="${switch}"
			fi
			acd_switches+=( "${param}" )
			acd_params["${switch}"]="${value}"
		else
			acd_argv+=("${param}")
		fi
	done
	
	adpn_debug 15 "${__ALIASFILE__}:${LINENO}" "%s(%s) %s" "adpn_check_dependency" "$( join_by ", " "${acd_argv[@]:1}" )" "$( join_by " " "${acd_switches[@]}" )"

	local dependency="${acd_argv[1]}"
	local description="${acd_argv[2]}" ; shift
	local instruction="${acd_argv[3]}" ; shift

	local result=0

	local dep_type=$( printf "%s" "${dependency}" | cut --field=1 --delimiter=":" --only-delimited )
	local dep_name=$( printf "%s" "${dependency}" | cut --field=2 --delimiter=":" )
	
	if [[ -n "${dependency}" ]] ; then
	
		case "${dep_type}" in
		"")
			which "${dep_name}" > /dev/null || result="$?"
			;;
		"apt")
			which "${dep_type}" &>/dev/null && if [[ -n "${dep_name}" ]] ; then
				dpkg -s "${dep_name}" &> /dev/null ; result="$?"
			fi
			;;
		"yum")
			which "${dep_type}" &>/dev/null && if [[ -n "${dep_name}" ]] ; then
				yum list installed "${dep_name}" &> /dev/null ; result="$?"
			fi
			;;
		"python")
			local PYTHON_IMPORT=$( printf "import %s" "${dep_name}" )
			python3 -c "${PYTHON_IMPORT}" 2>/dev/null || result="$?"
			;;
		*)
			;;
		esac
	fi
	
	if [[ "${result}" -gt 0 ]] ; then
		printf "Dependency Failure: %s." "${dep_name}" 1>&2
		if [[ -n "${description}" ]] ; then
			local s_desc=$( printf "${description}" "${dep_name}" )
			printf " This script requires the %s." "${s_desc}" 1>&2
		fi
		printf "\n" 1>&2
		
		if [[ -n "${instruction}" ]] ; then
			if [[ -n "${acd_params[interactive]}" ]] ; then
				read -n 1 -p "Install using command (${instruction}) (y/N)? " INST_YN < /dev/tty
				INST_YN=$( printf "%s" "${INST_YN}" | tr "[:lower:]" "[:upper:]" )
				printf "\n"
			else
				INST_YN="N"
			fi
			
			if [[ "Y" == "${INST_YN}" ]] ; then
				sudo su -c "${instruction}" < /dev/tty ; result="$?"
			else
				printf "To resolve this failure, use: %s\n" "${instruction}" 1>&2
			fi
		fi

		if [[ -n "${acd_params[or-die]}" ]] ; then
			exit 255
		fi
		
	fi

	return "${result}"
}

# adpn_help_notes: get help or usage notes included in the script comments,
# marked off with a @package or @method docblock directive
#
# @param string path to the script file; packages should be named the same
#               as the command base name (e.g. script adpn = @package adpn)
# @param string optional, method name
# @param string optional, context of call, used in error messages
# @return int exit code, 0=success; 255=no help notes for package or method
#
# @version 2021.0407

function adpn_help_notes () {
	local scriptpath="${1}" ; shift
	local method="${1}" ; shift
	local context="${1}" ; shift

	if [[ -n "${context}" ]] ; then
		context=" ${context}"
	fi
	
	local package=$(basename "${scriptpath}")
	local directive="[@]package ${package}\b"
	local HELPNOTES=""
	
	if [[ ! -z "${method}" ]] ; then
		directive="[@]method ${package} ${method}\b"
	fi
	
	HELPNOTES=$( sed --quiet "/^[#] ${directive}/,/^[#] @version/p" ${scriptpath} )
	
	if [ -z "${HELPNOTES}" ] ; then
		echo "[${package}${context}] '${method}' help notes not yet implemented." 1>&2
		EXITCODE=255
	else 
		echo "${HELPNOTES}" | grep "^[#]" | grep -v "^[#] [@]" | sed "s/^[#] *//"
		EXITCODE=0
	fi
	
	return "${EXITCODE}"
}

function adpn_notice() {
	local line="${1}" ; shift
	declare -a DBG_MESSAGE=( "$@" )
	
	local message="$1"
	if [[ "$#" -gt 1 ]] ; then
		message="$( printf -- "$@" )"
	fi
	
	printf "[%s] %s (%s:%d)\n" "${SCRIPT_CMD_NAME}" "${message}" "${SCRIPT}" "${line}" 1>&2
}

function adpn_debug() {
	local level="${1}" ; shift
	local line="${1}" ; shift
	declare -a DBG_MESSAGE=( "$@" )
	
	local -a tags=( $( printf "%s" "${level}" | tr "," "\n" | tail -n +2 ) )
	level=$( printf "%s" "${level}" | cut --delimiter="," --field=1 )

	local message="$1"
	if [[ "$#" -gt 1 ]] ; then
		message="$( printf -- "$@" )"
	fi
	
	local cmd="${SCRIPT_CMD_NAME}"
	[[ -z "${cmd}" ]] && cmd="${SCRIPT}"
	
	local line_source="${line}"
	if [[ "${line_source}" =~ ^[0-9]+$ ]] ; then
		line_source=$( printf "%s:%d" "${SCRIPT}" "${line}" )
	fi
	
	if [[ -n "${DBG}" ]] ; then
		local dbg_tag_list=$( join_by "|" "${DBGTAGS[@]}" )
		local dbg_tag_regex=$( printf "(%s)" "${dbg_tag_list}" )
		
		local b_display=0
		local s_why=""
		[[ "${DBGLEVEL}" -ge "${level}" ]] && b_display=1 && s_why=$( printf "|D%03d" "${level}" )
		for TAG in "${tags[@]}" ; do
			[[ -n "${TAG}" && "${TAG}" =~ ^${dbg_tag_regex}$ ]] && b_display=1 && s_why=$( printf "%s/DBG=%s" "${s_why}" "${TAG}" )
		done
		for TAG in "${tags[@]}" ; do
			[[ -n "${TAG}" && "-${TAG}" =~ ^${dbg_tag_regex}$ ]] && b_display=0
		done

		if [[ b_display -gt 0 ]] ; then
			printf "[%s%s] %s (%s)\n" "${cmd}" "${s_why}" "${message}" "${line_source}" 1>&2
		fi
	fi
}

function echo_header() {
	local title="${1}"
	local underline="${2}"
	
	UPTITLE=$( echo "${title}" | tr "[:lower:]" "[:upper:]" )
	UNDERLINE=$( echo "${UPTITLE}" | sed "s/./${underline}/g" )
	
	echo ""
	echo "${UPTITLE}"
	echo "${UNDERLINE}"
}

function adpn_read_json_packet_source() {
	local PACKET_SOURCE="${1}"
	local ME="${2}"
	local CONTEXT="${3}"
	local V="${4}"
	local result=0
	
	declare -a AGGP_SW=()

	AGJP_PACKETS="$(mktemp)"
	GITLAB_ISSUE=$( "${ME}" gitlab parse "${PACKET_SOURCE}" ${DDBG} )
	
	if [[ -z "${PACKET_SOURCE}" || "${PACKET_SOURCE}" == "-" ]] ; then
		cat - > "${AGJP_PACKETS}"
	elif [[ -n "${GITLAB_ISSUE}" ]] ; then
		if [[ -n "${V}" ]] ; then
			printf "* Retrieving JSON for Gitlab issue: %s\n" "${GITLAB_ISSUE}" 1>&2
		fi
		"${ME}" gitlab get packet "${GITLAB_ISSUE}" "${AGGP_SW[@]}" ${DDBG} > "${AGJP_PACKETS}"
		result="$?"
	elif [[ "${PACKET_SOURCE}" =~ ^https?:// ]] ; then
		if [[ -n "${V}" ]] ; then
			printf "* Retrieving manifest HTML for URL: %s\n" "${PACKET_SOURCE}" 1>&2
		fi
		curl --silent --fail "${PACKET_SOURCE}" > "${AGJP_PACKETS}"
		result="$?"
	elif [[ -r "${PACKET_SOURCE}" ]] ; then
		cp "${PACKET_SOURCE}" "${AGJP_PACKETS}"
	else
		printf "[%s] WARNING: Cannot locate any AU data from: '%s'\n" "${CONTEXT}" "${PACKET_SOURCE}" 1>&2
		result=1
	fi
	
	if [[ "${result}" -eq 0 ]] ; then
		cat "${AGJP_PACKETS}"
	fi
	rm "${AGJP_PACKETS}"
	return "${result}"
	
}

function adpn_write_json_packets_from () {
	local web_url="${1}" ; shift
	local -a json=( "$@" )
	local json_overlay="$( adpn-json.py --key="Gitlab Issue" --value="${web_url}" --prolog )"

	if [[ -n "${_PARAM[raw]}" ]] ; then
		printf "%s\n" "${json[@]}"
	else
		for json_packet in "${json[@]}" ; do
			printf "%s\n%s\n" "${json_packet}" "${json_overlay}" | adpn-json.py --cascade --output="application/json" --prolog ; printf "\n"
		done
	fi
}

( which python3 2>/dev/null >/dev/null ) && export ADPN_JSON_PACKET_REGEX="$( adpn-json.py --regex )"

# adpn_get_json_packets: filter an input stream for JSON packets, based on regex
# for a JSON packet or prolog from adpn-json.py 
# example: FOOBAR=$( adpnprop "${KEY}" )
#
# @param string file name of input to filter for JSON packets; "-" for stdin/pipeline
# @return int exit code from grep (0=success, 1=nothing found)
#
# @version 2021.0407

function adpn_get_json_packets() {
	local file="${1}"
	local packet=""
	local result=0

	if [[ -z "${file}" ]] ; then 
		file="-"
	fi
	
	packet=$( grep -P $ADPN_JSON_PACKET_REGEX "${file}" )
	result="$?"
	if [[ -n "${packet}" ]] ; then
		printf "%s\n" "${packet}"
	fi
	return "${result}"
}

function adpn_select_json_packet() {
	local piped_from="${1}"

	local packets_from="${2}"
	[[ -z "${packets_in}" ]] && packets_in="-"
	
	local -a filter=()
	IFS=" " read -ra filter <<< "${3}"
	[[ "${#filter[@]}" -eq 0 ]] && filter=( "head" "-n" "1" )
	
	if [[ "-" == "${packets_from}" || -r "${packets_from}" ]] ; then
		local GREP=""
		local packets_recvd="$( cat "${packets_from}" )"

		# 1. Are we looking for a packet with a specific "Ingest Step" setting? If so, look for that one & prefer it.
		if [[ -n "${piped_from}" ]] ; then
			adpn_debug 01 "${LINENO}" 'cat "%s" | adpn-json.py --output=application/json --where="Ingest Step:%s"\n' "${packets_from}" "${piped_from}"
			adpn_debug 50 "${LINENO}" 'adpn-json.py <<< ~~~\n%s\n~~~\n\n' "${packets_recvd}"
			
			GREP="$( printf "%s" "${packets_recvd}" | adpn-json.py --parse --output=application/json --where="Ingest Step:${piped_from}" )"
			result="$?"
			
			adpn_debug 50 "${LINENO}" 'adpn-json.py >>> ~~~\n%s\n~~~\n\n' "${GREP}"
			[[ -n "${GREP}" ]] && printf "%s" "${GREP}" | "${filter[@]}"
		fi
		
		# 2. If not, or if we haven't got that step, let's take one of the packets that seems to be available
		# -- Use FIRST for early (verify); LAST for late (promote, etc.); parameter provides a filter command,
		# e.g. head -n 1 or tail -n 1
		if [[ -z "${GREP}" ]] ; then
			adpn_debug 10 "${LINENO}" 'cat "%s" | adpn_get_json_packets | head -n 1\n' "${packets_from}"
			
			GREP="$( printf "%s" "${packets_recvd}" | adpn_get_json_packets | "${filter[@]}" )"
			result="$?"
			
			[[ "${GREP}" ]] && printf "%s" "${GREP}" || result=1
		fi
		
		adpn_debug 20 "${LINENO}" 'JSON source (%s) = <<<EOF\n%s\nEOF;\n\n' "${AIT_INPUT}" "${GREP}"
	else
		result=2
	fi
	return "${result}"
}

function adpn_opened_get_labels() {
	local tag=""
	local -a labels=()
	for tag in "$@" ; do
		if [[ "${tag}" =~ ^[/](.*)$ ]] ; then
			label_prefix="DONE:"
			label_content="${BASH_REMATCH[1]//_/ }"
		elif [[ "${tag}" =~ crawl ]] ; then
			label_prefix="WAITING:"
			label_content="${tag//_/ }"
		else
			label_prefix="TODO:"
			label_content="${tag//_/ }"
		fi
		
		labels+=( "$(join_by " " "${label_prefix}" "${label_content}" )" )
	done
	
	join_by "," "${labels[@]}"
}

function adpn_packet2lockssid() {
	local JSON_PACKET=$( cat - | adpn-json.py --output="application/json" )
	local PLUGIN_ID=$( printf "%s" "${JSON_PACKET}" | adpn-json.py --key="Plugin ID" )

	IFS=""
	shopt -s lastpipe

	local -a PARAMETERS=()
	printf "%s" "${JSON_PACKET}" | adpn-json.py --key="parameters" | while read -r LINE ; do
		local KEY=$( printf "%s\n" "${LINE}" | cut --field=1 )
		local VALUE=$( printf "%s\n" "${LINE}" | cut --field=2- )
		local ENCKEY=$( rawurlencode "${KEY}" 2 )
		local ENCVALUE=$( rawurlencode "${VALUE}" 2 )
		PARAMETERS+=( "$( printf "%s~%s\n" "${ENCKEY}" "${ENCVALUE}" )" )
	done
	
	local ALL_PARAMETERS="$( join_by "&" "${PARAMETERS[@]}" )"
	local LOCKSS_ID="$( printf "%s&%s" "${PLUGIN_ID//./|}" "${ALL_PARAMETERS}" )"
	rawurlencode "${LOCKSS_ID}" 2
}

function adpn_packet2daemonstatusurl() {
	local DAEMON="$( adpn_parameter_from ".daemon" )"
	[[ "${DAEMON}" =~ ^[A-Za-z]+[:][/][/] ]] || DAEMON="http://${DAEMON}"
	[[ "${DAEMON}" =~ :[0-9]+ ]] || DAEMON="${DAEMON}:8081/"
	DAEMON="$( printf "%s" "${DAEMON}" | sed -E 's/\/+$//' )"
	
	local URL_PREFIX="${DAEMON}/DaemonStatus?table=ArchivalUnitTable&key="
	local LOCKSSID="$( cat - | adpn_packet2lockssid )"
	printf "%s%s" "${URL_PREFIX}" "${LOCKSSID}"
}

function adpn_packet2daemonstatustable() {
	local URL="$( cat - | adpn_packet2daemonstatusurl )&output=text"
	local USER="$( adpn_parameter_from ".daemon/user" )"
	local PASS="$( adpn_parameter_from ".daemon/pass" )"
	local CREDENTIALS="${USER}:$( adpn_getpassword_from "${PASS}" )"
	local PREFIX="${1}"
	
	LATER=0
	local CURLOUT="$( curl --fail --silent "${URL}" --user "${CREDENTIALS}" )"
	local result="$?"
	
	printf "%s" "${CURLOUT}" | while read -r LINE ; do
		if [[ -n "${LINE}" ]] ; then
			[[ "${LINE}" =~ ^$PREFIX[=] ]] && [[ "${LATER}" -gt 0 ]] && printf "\n%s \n" "--"
			[[ "${LINE}" =~ ^$PREFIX[=] ]] && printf "%s\n" "${LINE}" | sed -E 's/([^\\]),/\1\n/g' && LATER=1

		fi
	done
	[[ "${LATER}" -gt 0 ]] || result=1

	return "${result}"
}

function adpn_check_au_status() {
	local LINE=""
	local -a switches=()
	local -A params=()
	local key
	local value
	
	for switch in "$@" ; do
		if [[ "${switch}" =~ ^--([A-Za-z_0-9][^=]*)(=(.*))?$ ]] ; then
			key="${BASH_REMATCH[1]}"
			[[ -z "${BASH_REMATCH[2]}" ]] && value="${key}" || value="${BASH_REMATCH[3]}"
			
			switches+=( "${switch}" )
			params["${switch}"]="${value}"
		fi
	done
	
	shopt -s lastpipe
	local result=0
	local piped_input="$( cat - )"
	IFS="" printf "%s\n" "${piped_input}" | while read -r LINE ; do
		key="$( printf "%s" "${LINE}" | cut --field=1 )"
		value="$( printf "%s" "${LINE}" | cut -s --fields=2- )"
		if [[ -n "${key}" ]] ; then
			
			local status=""
			
			if [[ "${key}" =~ ^Last[^A-Za-z0-9] ]] ; then
				local TS=""
				local TS_EXIT=0
				if [[ "${value}" =~ ^[0-9]+$ ]] ; then
					TS=$(( "${value}" / 1000 ))
					TS="$( date --date="@${TS}" )" ; TS_EXIT="$?"
					[[ "${TS_EXIT}" -eq 0 ]] && { value="${TS}" ; status="(ok!) " ; }
				fi
			fi
			
			case "${key}" in
			"Status")
				[[ "${value}" == "100.00% Agreement" ]] && status="(ok!) " || { status="(??) " ; result=1 ; }
				;;
			"Last Crawl Result")
				[[ "${value}" == "Successful" ]] && status="(ok!) " || { status="(??) " ; result=1 ; }
				;;
			"Last Poll Result")
				[[ "${value}" == "Complete" ]] && status="(ok!) " || { status="(??) " ; result=1 ; }
				;;
			*)
				# NOOP
				;;
			esac

			printf "%s%s:\t%s\n" "${status}" "${key}" "${value}"
		fi
	done
	
	return "${result}"
}

function obscure_password() {
	local text=""
	for text in "$@" ; do
		printf "%s" "${text}" | sed -E 's/./*/g'
	done
}

# rawurlencode: Encode a command-line parameter to URL (%hex) style encoding and output
# example: FOOBAR=$( rawurlencode "${DATA}" )
# uses code from @Orwellophile at https://stackoverflow.com/questions/296536/how-to-urlencode-data-for-curl-command
# @version 2019.0807
rawurlencode() {
  local string="${1}"
  local strlen=${#string}
  local encoded=""
  local pos c o
  local level="${2}"
  
  for (( pos=0 ; pos<strlen ; pos++ )); do
     c=${string:$pos:1}
     case "$c" in
        [-_a-zA-Z0-9] ) 	o="${c}" ;;
        [.~] )          	[[ "${level}" -ge 2 ]] && printf -v o '%%%02X' "'$c" || o="${c}" ;;
        * )             	printf -v o '%%%02X' "'$c"
     esac
     encoded+="${o}"
  done
  echo "${encoded}"    # You can either set a return variable (FASTER) 
  REPLY="${encoded}"   #+or echo the result (EASIER)... or both... :p
}

# urldecode: Decodes a command-line parameter from URL (%hex) style encoding to plain text
# one-liner solution provided by @guest and @netdesignate at https://stackoverflow.com/a/37840948
function urldecode() { : "${*//+/ }"; echo -e "${_//%/\\x}"; }

# join_by: Joins a list of parameters using a delimiter string
# one-liner solution provided by @Nicholas Sushkin at https://stackoverflow.com/a/17841619
function join_by { local d=${1-} f=${2-}; if shift 2; then printf %s "$f" "${@/#/$d}"; fi; }

function strtotitle {
	for WORD in "$@" ; do
		printf "%s%s\n" "$( printf "%s" "${WORD:0:1}" | tr "[:lower:]" "[:upper:]" )" "${WORD:1}"
	done
}
