#!/bin/bash
#
# adpn-do-rebalance: script to handle adpn rebalance commands
#
# @version 2021.0224

SCRIPTPATH="$(which "$0")"
SCRIPTPATH="$( readlink --canonicalize "${SCRIPTPATH}" )"
SCRIPTDIR="$(dirname "${SCRIPTPATH}")"
SCRIPT="$(basename "${SCRIPTPATH}")"

source "${SCRIPTDIR}/adpn-define-aliases"

__USAGE__="Usage: ${SCRIPT} [--version] [--help] <CMD> [<ARGS>]"
__HELP__="[${SCRIPT}] Try '${SCRIPT} help' for more information."
__DOC__="""${__USAGE__}

  --version 	Display the version of the script
  --help    	Display these usage notes

The most commonly used ${SCRIPT} commands are:
  destination  	Output a destination directory for the rebalanced AU
  
Exit codes:
0 = success (successful operation and expected result)
1-254 = error in executing command
255 = command not supported
"""

##########################################################################################
### COMMAND LINE: loop through switches ##################################################
##########################################################################################

declare -a _ARGV ; _ARGV=("$0")
declare -a _CMDLINE ; _CMDLINE=("$0")
declare -A _PARAM=()

shopt -s lastpipe

declare -a SWITCHFILES ; SWITCHFILES=()
if [[ -r "${CONFFILE}" ]] ; then
	SWITCHFILES+=(${CONFFILE})
fi

CMDLINETXT=$(mktemp)

until [[ "$#" -lt 1 ]] ; do
	_CMDLINE+=("$1")
	printf "%s\n" "$1" >> "${CMDLINETXT}"
	shift
done

SWITCHFILES+=(${CMDLINETXT})

adpn_command_line "${SWITCHFILES[@]}"

rm "${CMDLINETXT}"

##########################################################################################
### SCRIPT: DETERMINE COMMAND, THEN EXECUTE PIPELINE  ####################################
##########################################################################################

EXITCODE=0

V="${_LINESWITCH[verbose]}"
CMD="${_ARGV[1]}"

SCRIPT_CMD_NAME="${_PARAM[context]}"
if [[ -z "${SCRIPT_CMD_NAME}" ]] ; then
	SCRIPT_CMD_NAME="${SCRIPT}"
fi
if [[ -n "${CMD}" ]] ; then
	SCRIPT_CMD_NAME="${SCRIPT_CMD_NAME} ${CMD}"
fi

if [[ ! -z "${_PARAM[version]}" ]] ; then
	VERSION=$(grep "^# @version" $0 | head --lines=1 | cut --only-delimited --fields=3- --delimiter=" ")
	echo "${SCRIPT_CMD_NAME} version ${VERSION}"
	CMD="version"
fi

if [[ ! -z "${_PARAM[help]}" ]] ; then
	echo "${__DOC__}"
	CMD="help"
fi

case "${CMD}" in
		
	""|"list")
# @method adpn rebalance list
# Display a list of available cache directories with free space.
# 
# Usage: adpn rebalance list
#
# @version 2021.0224

		if [[ -z "${CMD}" ]] ; then
			CMD="list"
		fi
		
		# look for a list of LOCKSS cache directories.
		GAMMAS=$( find / -maxdepth 2 -name 'gamma' 2>/dev/null )
		
		printf "[%s] Available cache volumes:\n\n" "${SCRIPT} ${CMD}"
		printf "%s" "${GAMMAS}" | xargs df --human-readable
		EXITCODE="$?"
		;;
	
	"script")
# @method adpn rebalance script
# Generate and print out a short bash script to rebalance from one volume to the next.
# The script that is produced MUST be run by root or a user with sudo privileges.
# 
# Usage: 	adpn rebalance script [<AU>] <SOURCE> <DESTINATION> [<OPTIONS>]...
#
# AU is the letter code for the AU directory.
#   Example: to rebalance /cache0/gamma/cache/abc to /cache1, use: adpn rebalance script abc /cache0 /cache1
#
# SOURCE is the file system location of the LOCKSS cache volume that HAS the AU.
#   If AU is NOT specified, use the full path to the AU directory:
#   Example: adpn rebalance /cache0/gamma/cache/abc /cache1
#   If AU IS specified, you can abbreviate to  the mount point for the volume:
#   Example: adpn rebalance abc /cache0 /cache1
#
# DESTINATION is the file system location of the LOCKSS cache volume where you WILL MOVE the AU.
#   Example: adpn rebalance script /cache0/gamma/cache/abc /cache1
#   to rebalance cache/abc from /cache0 to /cache1
#
# @version 2021.0224

		declare -a WORDS
		WORDS=( "${_ARGV[@]:2}" )

		ARG_OBJECT="${_PARAM[au]}"
		if [[ -z "${ARG_OBJECT}" ]] ; then
			ARG_OBJECT="${WORDS[0]}"
			WORDS=( "${WORDS[@]:1}" )			
		fi
		
		ARG_SRC="${_PARAM[from]}"
		if [[ -z "${ARG_SRC}" ]] ; then
			ARG_SRC="${WORDS[0]}"
			WORDS=( "${WORDS[@]:1}" )
		fi
		
		ARG_DEST="${_PARAM[to]}"
		if [[ -z "${ARG_DEST}" ]] ; then
			ARG_DEST="${WORDS[0]}"
			WORDS=( "${WORDS[@]:1}" )
			
			if [[ -z "${ARG_DEST}" ]] ; then
				ARG_DEST="${ARG_SRC}"
				ARG_SRC="$( dirname "${ARG_OBJECT}" )"
				ARG_OBJECT="$( basename "${ARG_OBJECT}" )"
			fi

		fi
		
		
		SRC_GAMMA=$( "${SCRIPTPATH}" destination --gamma "${ARG_SRC}" )
		SRC=$( printf "%s/cache/%s" "${SRC_GAMMA}" "${ARG_OBJECT}" )
		SRC_HIDDEN=$( printf "%s/hide/%s" "${SRC_GAMMA}" "${ARG_OBJECT}" )
		INTERMEDIATE_GAMMA=$( "${SCRIPTPATH}" destination --gamma "${ARG_DEST}" )
		INTERMEDIATE_DEST=$( printf "%s/copy/%s" "${INTERMEDIATE_GAMMA}" "${ARG_OBJECT}" )
		FINAL_DEST=$( "${SCRIPTPATH}" destination "${ARG_DEST}" )

		printf '#!/bin/bash\n'
		printf '#\n'
		printf '# generated by %s@%s at %s\n' "${USER}" "$( uname -n )" "$( date )"
		printf '\n'
		SCRIPTCMD=$( printf '"%s" sync %s --from="%s" --to="%s"' "${SCRIPTPATH}" "${V}" "${SRC}" "${INTERMEDIATE_DEST}" )
		SCRIPTPROMPT=$( printf 'read -p %scmd: [%s] Enter OK to continue: %s OK' "'" "${SCRIPTCMD}" "'" )
		SCRIPTOK='OK="$( printf "%s" "${OK}" | tr "[:upper:]" "[:lower:]")"'
		printf "%s\n" "${SCRIPTPROMPT}"
		printf "%s\n" "${SCRIPTOK}"
		printf "%s %s ; %s\n" 'if [[ "${OK}" == "ok" ]] ; then' "${SCRIPTCMD}" 'fi'
		
		SCRIPTCMD=$( printf '"%s" resettle %s --from="%s" --to="%s"' "${SCRIPTPATH}" "${V}" "${INTERMEDIATE_DEST}" "${FINAL_DEST}" )
		SCRIPTPROMPT=$( printf 'read -p %scmd: [%s] Enter OK to continue: %s OK' "'" "${SCRIPTCMD}" "'" )
		printf "%s\n" "${SCRIPTPROMPT}"
		printf "%s\n" "${SCRIPTOK}"
		printf "%s %s ; %s\n" 'if [[ "${OK}" == "ok" ]] ; then' "${SCRIPTCMD}" 'fi'

		SCRIPTCMD=$( printf '"%s" resettle %s --from="%s" --to="%s"' "${SCRIPTPATH}" "${V}" "${SRC}" "${SRC_HIDDEN}" )
		SCRIPTPROMPT=$( printf 'read -p %scmd: [%s] Enter OK to continue: %s OK' "'" "${SCRIPTCMD}" "'" )
		printf "%s\n" "${SCRIPTPROMPT}"
		printf "%s\n" "${SCRIPTOK}"
		printf "%s %s ; %s\n" 'if [[ "${OK}" == "ok" ]] ; then' "${SCRIPTCMD}" 'fi'
 		
		;;
	
	"lockdown")
		CONF_DIR="/cache0/gamma/config"
		if [[ -n "${_PARAMS[config]}" ]] ; then
			CONF_DIR="${_PARAMS[config]}"
		fi
		
		if [[ -d "${CONF_DIR}" ]] ; then
			cd "${CONF_DIR}"
			if [[ -w "${CONF_DIR}/expert_config.txt" ]] ; then
				__DISABLER__="""org.lockss.crawler.enabled=false
org.lockss.poll.v3.enableV3Poller=false
org.lockss.poll.v3.enableV3Voter=false
"""
				CONF_TXT="${CONF_DIR}/expert_config.txt"
				if [[ -n "${_PARAM[revoke]}" ]] ; then
					CONF_TMP_TXT=$( mktemp expert_config_XXXXXX --suffix=.txt )
					FIRST_LINE="$( printf "%s" "${__DISABLER__}" | head -n 1 )"
					LAST_LINE="$( printf "%s" "${__DISABLER__}" | tail -n 1 )"
					
					sed "/^${FIRST_LINE}/,/^${LAST_LINE}/d" "${CONF_TXT}" > "${CONF_TMP_TXT}"
					if [[ -n "${V}" ]] ; then
						diff -u "${CONF_TXT}" "${CONF_TMP_TXT}"
					fi
					
					mv ${V} "${CONF_TXT}" "${CONF_TXT}~"
					mv ${V} "${CONF_TMP_TXT}" "${CONF_TXT}"

				else
					cp ${V} "${CONF_TXT}" "${CONF_TXT}~"
					printf "%s" "${__DISABLER__}" >> "${CONF_TXT}"
					if [[ -n "${V}" ]] ; then
						diff -u "${CONF_TXT}~" "${CONF_TXT}"
					fi
				fi
				
			elif [[ ! -f "${CONF_DIR}/expert_config.txt" ]] ; then
				printf "[%s] Error: LOCKSS expert_config.txt file not found at %s\n" "${SCRIPT_CMD_NAME}" "${CONF_DIR}" 1>&2
				EXITCODE=255

			else 
				printf "[%s] Error: cannot edit LOCKSS expert_config.txt file at %s\n" "${SCRIPT_CMD_NAME}" "${CONF_DIR}" 1>&2
				EXITCODE=255
			
			fi
			
		else
			printf "[%s] Error: LOCKSS config directory not found at %s\n" "${SCRIPT_CMD_NAME}" "${CONF_DIR}" 1>&2
			printf "If you know the correct directory for LOCKSS config, use %s %s --config=[<DIR>]\n" "${SCRIPT}" "${CMD}" 1>&2
			EXITCODE=255
		fi		
		;;
		
	"sync")
		"${SCRIPTPATH}" secure ${V} --context="${SCRIPT_CMD_NAME}" --from="${_PARAM[from]}" --to="${_PARAM[to]}" ; EXITCODE=$?
		if [[ "${EXITCODE}" -eq 0 ]] ; then
			IC=""
			if [[ -n "${V}" ]] ; then
				IC="--itemize-changes"
			fi
			
			sudo rsync --archive ${IC} "${_PARAM[from]}/" "${_PARAM[to]}"
			EXITCODE=$?
		fi
		;;

	"resettle")
		"${SCRIPTPATH}" secure ${V} --context="${SCRIPT_CMD_NAME}" --from="${_PARAM[from]}" --to="${_PARAM[to]}" ; EXITCODE=$?
		if [[ "${EXITCODE}" -eq 0 ]] ; then
			sudo mv ${V} "${_PARAM[from]}" "${_PARAM[to]}"
			EXITCODE=$?
		fi
		;;

	"secure")
		FROM="${_PARAM[from]}"
		TO="${_PARAM[to]}"
		
		if [[ -n "${_PARAM[context]}" ]] ; then
			SCRIPT_CMD_NAME="${_PARAM[context]}"
		fi
		
		if [[ -z "${FROM}" ]] ; then
			printf "[%s] REQUIRED: --from=[<SRC>]\n" "${SCRIPT_CMD_NAME}" 1>&2
			EXITCODE=255
		elif [[ -z "${TO}" ]] ; then
			printf "[%s] REQUIRED: --to=[<DEST>]\n" "${SCRIPT_CMD_NAME}" 1>&2
			EXITCODE=255
		else
			# secure the destination directory's existence and permissions, if necessary
			TO_DIR="$( dirname "${TO}" )"
			TO_PARENT="$( dirname "${TO_DIR}" )"
			REF_DIR="${TO_PARENT}/cache"

			if [[ ! -d "${TO_DIR}" ]] ; then
				sudo mkdir --parents ${V} "${TO_DIR}"
				if [[ -d "${REF_DIR}" ]] ; then
					sudo chown ${V} --reference="${REF_DIR}" "${TO_DIR}"
					sudo chmod ${V} --reference="${REF_DIR}" "${TO_DIR}"
				fi
			fi
			test -d "${TO_DIR}" ; EXITCODE=$?
		fi
		;;
		
	"destination")
# @method adpn rebalance destination
# Generates and displays a directory name for the next available AU directory in a LOCKSS cache volume.
#
# Usage: adpn rebalance destination [<DIRECTORY>] [<OPTIONS>]...
#
# DIRECTORY is a path to one or more of the LOCKSS cache volumes on your LOCKSS box. These are usually
# called things like /cache0, /cache1, /cache2, etc. If in doubt, you can use the `adpn rebalance list`
# command to get a list of likely candidates:
#
# 	adpn rebalance list.
#
# @version 2021.0224

		declare -a DESTINATION_VOLUMES=()
		if [[ "${_PARAM[on]}" ]] ; then
			DESTINATION_VOLUMES+=("${_PARAM[on]}")
		fi
		for DESTINATION in "${_ARGV[@]:2}" ; do
			DESTINATION_VOLUMES+=("${DESTINATION}")
		done
		
		if [[ "${#DESTINATION_VOLUMES[@]}" -gt 0 ]] ; then
			for DESTINATION in "${DESTINATION_VOLUMES[@]}" ; do
				CACHE_DIR=$( find "${DESTINATION}" -maxdepth 2 -path '*/gamma/cache' )
				if [[ -d "${CACHE_DIR}" ]] ; then
					if [[ -z "${_PARAM[gamma]}" ]] ; then
						cd "${CACHE_DIR}"

						SLUGS=$( find . -maxdepth 1 -type d | xargs -n 1 basename )
						LONGEST=$( printf "%s" "${SLUGS}" | wc -L )
						PATTERN=$( printf '^[a-z]{%d}' "${LONGEST}" )
						LAST_IN_TRANCHE=$( printf "%s" "${SLUGS}" | grep -E "${PATTERN}" | sort -r | head -n 1 )
						NEXT_IN_TRANCHE=$( "${SCRIPTPATH}" increment --carry "${LAST_IN_TRANCHE}" )
						
						if [[ -n "${V}" ]] ; then
							printf "[%s %s] Last AU cache directory on %s: %s\n" "${SCRIPT}" "${CMD}" "${DESTINATION}" "${LAST_IN_TRANCHE}" 1>&2
							if [[ -n "${NEXT_IN_TRANCHE}" ]] ; then
								printf "[%s %s] Next AU cache directory on %s: %s\n" "${SCRIPT}" "${CMD}" "${DESTINATION}" "${NEXT_IN_TRANCHE}" 1>&2
							fi
						fi
						
						if [[ -n "${NEXT_IN_TRANCHE}" ]] ; then
							printf "%s/%s\n" "${CACHE_DIR}" "${NEXT_IN_TRANCHE}"
						else
							printf "[%s %s] Could not determine next AU cache directory on %s !\n" "${SCRIPT}" "${CMD}" "${DESTINATION}" 1>&2
							EXITCODE=1
						fi
					
					else
						GAMMA_DIR=$( dirname "${CACHE_DIR}" )
						printf "%s\n" "${GAMMA_DIR}"

					fi
				fi
			done
		else
			EXITCODE=1
			printf "[%s %s] You need to mention one or more LOCKSS volumes. Usage:\n\n" "${SCRIPT}" "${CMD}" 1>&2
			# FIXME - we need to be able to use adpn_help_notes or similar in sub-scripts....
		fi
		;;
	
	"increment")
		
		if [[ -n "${_PARAM[carry]}" ]] ; then
			if [[ -z "${_ARGV[2]}" ]] ; then
				_ARGV[2]="_"
			fi
		fi
		
		for DIGITS in "${_ARGV[@]:2}" ; do

			LEASTSIG="${DIGITS: -1}"
			MOSTSIG="${DIGITS:0: -1}"
			
			INC=$( printf "%s" "${LEASTSIG}" | tr "_a-z" "a-z_" )
			if [[ "${INC}" == "_" ]] ; then

				# Carry me back to the most significant digits
				MOSTSIG=$( "${SCRIPTPATH}" "${CMD}" --carry "${MOSTSIG}" )
				INC="a"

			fi
			
			OUTPUT="${MOSTSIG}${INC}"
			if [[ -n "${V}" ]] ; then
				printf "INCREMENTED: %s\n" "${OUTPUT}" 1>&2
			fi
			printf "%s\n" "${OUTPUT}"
		done
		
		;;
		
	"version"|"help")
		EXITCODE=0
		;;
		
	*)
		echo "[${SCRIPT_CMD_NAME}] '${CMD}' command not understood." 1>&2
		echo "${__HELP__}" 1>&2
		EXITCODE=255
		;;
esac

##########################################################################################
### CLEANUP: remove temporary output file. ###############################################
##########################################################################################

exit ${EXITCODE}
