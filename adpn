#!/bin/bash
#
# adpn: master script for scripted ADPNet operations.
#
# @version 2021.0712

SCRIPTPATH="$( which "$0" )"
SCRIPTPATH="$( readlink --canonicalize "${SCRIPTPATH}" )"
SCRIPTDIR="$( dirname "${SCRIPTPATH}" )"
SCRIPT="$( basename "${SCRIPTPATH}" )"
ME="${SCRIPTPATH}"

source "${SCRIPTDIR}/adpn-define-aliases"

__USAGE__="Usage: ${SCRIPT} [--version] [--help] <CMD> [<ARGS>]"
__HELP__="Try '${SCRIPT} help' for more information."
__DOC__="""${__USAGE__}

  --version 	Display the version of the script
  --help    	Display these usage notes

The most commonly used ${SCRIPT} commands are:
  preserve  	ADPNet Member: prepare an AU for preservation and notify config manager
  verify    	Node Manager: accept an AU from Member, test, and confirm accessibility from your node
  accept    	Config Manager: accept a verified AU from Node, test, and insert into titlesdb
  promote   	Config Manager: publish an accepted Member's AU to the entire network
  help      	Display usage notes for the ${SCRIPT} script or for a given command
  
Exit codes:
0 = success (successful retrieval and expected result)
1-254 = error in executing command
255 = command not supported
"""

##########################################################################################
### COMMAND LINE: loop through switches ##################################################
##########################################################################################

declare -a _ARGV ; _ARGV=("$0")
declare -a _CMDLINE ; _CMDLINE=("$0")
declare -A _PARAM=( )

shopt -s lastpipe

declare -a SWITCHFILES ; SWITCHFILES=()
if [[ -r "${CONFFILE}" ]] ; then
	SWITCHFILES+=(${CONFFILE})
fi

CMDLINETXT=$(mktemp)

until [[ "$#" -lt 1 ]] ; do
	_CMDLINE+=("$1")
	printf "%s\n" "$1" >> "${CMDLINETXT}"
	shift
done

SWITCHFILES+=(${CMDLINETXT})

adpn_command_line "${SWITCHFILES[@]}"

rm "${CMDLINETXT}"

##########################################################################################
### SCRIPT: DETERMINE COMMAND & SHARED SETTINGS ##########################################
##########################################################################################

EXITCODE=0
CMD="${_ARGV[1]}"

VV="${_LINESWITCH[verbose]}"
QQ="${_LINESWITCH[quiet]}"
V="${_LINESWITCH[verbose]}"
Q=""

DBG="${_LINESWITCH[debug]}"
DBGLEVEL="${_PARAM[debug]}"
if [[ "${DBGLEVEL}" == "debug" ]] ; then
	DBGLEVEL=1
fi
if [[ "${DBGLEVEL}" -gt 1 ]] ; then
	DBGLEVEL=$(( DBGLEVEL - 1 ))
	DDBG="--debug=${DBGLEVEL}"
else
	DDBG=""
fi

SCRIPT_CMD_NAME="${_PARAM[context]}"
if [[ -z "${SCRIPT_CMD_NAME}" ]] ; then
	SCRIPT_CMD_NAME="${SCRIPT}"
	if [[ -n "${CMD}" ]] ; then
		SCRIPT_CMD_NAME="${SCRIPT_CMD_NAME} ${CMD}"
	fi
fi

if [[ ! -z "${_PARAM[version]}" ]] ; then
	if [[ -z "${CMD}" ]] ; then
		CMD="version"
	else
		"${ME}" version
	fi
fi

if [[ ! -z "${_PARAM[help]}" ]] ; then
	CMD="help"
	_ARGV=( "help" "${_ARGV[@]}" )
fi

##########################################################################################
## COMMUNICATIONS: check for information to access encrypted persistent data #############
##########################################################################################

export ADPN_STASH_FILE
export ADPN_STASH_KEY
ADPN_STASH_CLOSE=""

if [[ "${CMD}" == "stash" ]] ; then
	# NOOP - prevent infinite recursion, double-execution, etc.
	ADPN_STASH_JSON=""
else
	# stash open: this will output some variable settings
	eval $( "${ME}" stash open --quiet --if-needed )
fi

##########################################################################################
### SCRIPT: EXECUTE PIPELINE  ############################################################
##########################################################################################

case "${CMD}" in
	"")
		printf "[%s:%d] command expected (for example: '${SCRIPT} preserve', '${SCRIPT} accept', etc.)\n" "${SCRIPT}" "${LINENO}" 1>&2
		printf "[%s:%d] %s\n" "${SCRIPT}" "${LINENO}" "${__HELP__}" 1>&2
		EXITCODE=255
		;;
		
	"version")
# @method adpn version
# Displays current version of the adpn script.
#
# Usage: adpn version
#
# @version 2019.0808
		VERSION=$(grep "^# @version" $0 | head --lines=1 | cut --only-delimited --fields=3- --delimiter=" ")
		echo "${SCRIPT} version ${VERSION}"
		EXITCODE=0
		;;
		
	"help")
# @method adpn help
# Displays usage notes for the adpn script or a given adpn script command
#
# Usage: adpn help [<CMD>]
#
# CMD is an adpn script pipeline command, e.g. "preserve", "ingest", "publish"
# If omitted, display usage notes for the adpn script as a whole.
#
# @version 2019.0715
		HELPCMD="${_ARGV[2]}"
		if [[ -z "${HELPCMD}" ]] ; then
			echo "${__DOC__}"
			EXITCODE=0
		else 
			adpn_help_notes "${ME}" "${HELPCMD}" "${CMD}"
			EXITCODE=$?
		fi
		;;
		
	"test")
# @method adpn test 
#
# Usage: adpn test [<TESTCODE>] [<CMD>] [<ARGS>]...
#
# TESTCODE is a code identifying the test data packet to use. For a list of available
# tests, use:
#
# 	adpn test
#
# CMD is an adpn script pipeline command, e.g "preserve", "ingest", "publish"
# ARGS are the arguments for that pipeline command.
#
# @version 2019.0715

		TESTDIR="${SCRIPTDIR}/json/tests"
		if [[ "${_ARGV[2]}" == "adpnprop" ]] ; then
			SETTING_VALUE="$( adpnprop "${_ARGV[@]:3}" )" ; EXITCODE="$?"
			printf "adpnprop: exit=%d, value='%s'\n" "${EXITCODE}" "${SETTING_VALUE}"
		elif [[ "${_ARGV[2]}" == "adpn_parameter_from" ]] ; then
			SETTING_VALUE="$( adpn_parameter_from "${_ARGV[@]:3}" )"
			printf "adpn_parameter_from: exit=%d, value='%s'\n" "${EXITCODE}" "${SETTING_VALUE}"
		elif [[ ! -z "${_CMDLINE[2]}" ]] ; then
			TESTFILE=${TESTDIR}/${_CMDLINE[2]}.json
			if [[ -r "${TESTFILE}" ]] ; then
				"${_CMDLINE[0]}" "${_CMDLINE[@]:3}" ${TESTFILE}
				EXITCODE="$?"
			else
				printf "[%s:%d] Use '%s [<TESTCODE>]'.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT} ${CMD}" 1>&2
				printf "\n" 1>&2
				printf "Available tests:\n" 1>&2
				cd $TESTDIR && ls ./*.json | sed 's/^.\//- /' | sed 's/[.]json$//' 1>&2
				EXITCODE=255
			fi
		else
			printf "[%s:%d] Use '%s [<TESTCODE>]'.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT} ${CMD}" 1>&2
			printf "\n" 1>&2
			printf "Available tests:\n" 1>&2
			cd $TESTDIR && ls ./*.json | sed 's/^.\//- /' | sed 's/[.]json$//' 1>&2
			EXITCODE=255
		fi
		;;
	
	"setup")
# @method adpn setup
# Perform initial setup for adpn script in a new environment.
#
# Usage: adpn setup [<CMD>] [--for=<CONTEXT>]
#
#    --for=preserve 	sets up adpn for use on your workstation to submit AUs
#    --for=verify   	sets up adpn for use on your preservation node to verify AUs
#    --for=ingest  		sets up adpn for use on the props server to ingest/publish AUs
#    --for=publish  	synonym for --for=ingest
#   
# @version 2021.0406
		adpn-do-setup all ${_LINESWITCH[for]} ${_LINESWITCH[verbose]} ${_LINESWITCH[quiet]} ${_LINESWITCH[debug]} --context="${SCRIPT_CMD_NAME}" --script="${SCRIPTPATH}"
		
		EXITCODE="$?"
		
		;;
		
	"property")
# @method adpn property
# Display property values from the configuration file (adpnet.json)
#
# Usage: adpn property [list|get <KEY>|set <KEY> <VALUE>]
#
# Example: adpn property get "peer"
#
# Output:
# * adpn property list # lists the available settings from the JSON hash table
# * adpn property get <KEY> # prints the value associated with <KEY> in the JSON hash table
# * adpn property set <KEY> <VALUE> # sets the value associated with <KEY> to <VALUE>
# 
# @version 2021.0406

		SUBCMD="${_ARGV[2]}"
		case "${SUBCMD}" in
			""|"list")
				adpnprop
				printf "\n"
				;;
			"get")
				adpnprop "${_ARGV[3]}"
				EXITCODE=$?
				;;
			"set")
				declare -a WORDS
				WORDS=( "${_ARGV[@]:3}" )
				if [[ -n "${_PARAM[key]}" ]] ; then
					KEY="${_PARAM[key]}"
				elif [[ -n "${WORDS[0]}" ]] ; then
					KEY="${WORDS[0]}"
					WORDS=( "${WORDS[@]:1}" )
				fi
				
				if [[ -n "${_PARAM[value]}" ]] ; then
					VALUE="${_PARAM[value]}"
				elif [[ -n "${WORDS[0]}" ]] ; then
					VALUE="${WORDS[0]}"
					WORDS=( "${WORDS[@]:1}" )
				fi
				
				APS_OUTPUT=$(mktemp)

				JSON_KEYVALUE="$( adpn-json.py --key="${KEY}" --value="${VALUE}" )"
				JSON_OTHERS="$( adpnprop --output=application/json )"
				printf "%s\n%s\n" "${JSON_OTHERS}" "${JSON_KEYVALUE}" | adpn-json.py --output="application/json;prettyprint" --cascade > "${APS_OUTPUT}"
				printf "\n" >> "${APS_OUTPUT}"

				JSONORIGINAL="$( readlink -f "${JSONCONFFILE}" )"
				JSONBACKUP="$( printf "%s~" "${JSONORIGINAL}" )"
				if [[ -r "${JSONORIGINAL}" ]] ; then
					cp "${JSONORIGINAL}" "${JSONBACKUP}"
				else
					printf "{}\n" > "${JSONBACKUP}"
				fi
				mv "${APS_OUTPUT}" "${JSONORIGINAL}"
				if [[ -z "${_PARAM[quiet]}" ]] ; then
					diff -u --color "${JSONBACKUP}" "${JSONORIGINAL}"
				fi
				
				EXITCODE=0
				;;
			*)
				printf "[%s:%d] '%s' command not understood.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SUBCMD}" 1>&2
				EXITCODE=255
				;;
		esac
		;;
	
	"stash")
		WORD="$( printf "%s" "${_ARGV[2]}" | tr "[:upper:]" "[:lower:]" )"
		declare -a ADPN_SECRETS_ARGS=( "${_ARGV[@]:3}" )
		
		ADPN_SECRET_COUPLE_KEY=""
		ADPN_JSON_TEMPLATE=""
		case "${WORD}" in
			"open")
			
				declare -a ADPN_STASH_SETTINGS_SHELL=()
				ADPN_STASH_SETTINGS_SHELL+=( "export ADPN_STASH_FILE='%(file)s'" )
				ADPN_STASH_SETTINGS_SHELL+=( "export ADPN_STASH_KEY='%(\$json)s'" )

				if [[ -z "${_PARAM[if-needed]}" || -z "${ADPN_STASH_KEY}" || -z "${ADPN_STASH_FILE}" || ! -e "${ADPN_STASH_FILE}" ]] ; then
					ADPN_STASH_JSON="$( printf '%s\n' '{}' | adpn-do-stash.py --put )"

					ADPN_STASH_FILE="$( printf '%s' "${ADPN_STASH_JSON}" | adpn-json.py --key=file )"
					ADPN_STASH_KEY="$( printf '%s' "${ADPN_STASH_JSON}" )"
					[[ -z "${_PARAM[keep]}" ]] && ADPN_STASH_SETTINGS_SHELL+=( "ADPN_STASH_CLOSE='%(file)s'" )

				else 
					ADPN_STASH_KEY_JSON=$( printf "%s" "${ADPN_STASH_KEY}" )
					ADPN_STASH_FILE_JSON=$( printf '{"file": "%s"}' "${ADPN_STASH_FILE}" )
					ADPN_STASH_CACHED_JSON='{ "cached": 1 }'
					ADPN_STASH_JSON=$( printf '%s\n%s\n%s' "${ADPN_STASH_KEY_JSON}" "${ADPN_STASH_FILE_JSON}" "${ADPN_STASH_CACHED_JSON}" | adpn-json.py --cascade --output=application/json )
				fi

				[[ -z "${QQ}" ]] && ADPN_STASH_SETTINGS_SHELL+=( "declare -p ADPN_STASH_FILE 1>&2" )
				ADPN_STASH_SETTINGS="$( join_by "; " "${ADPN_STASH_SETTINGS_SHELL[@]}" )"
			
				[[ -z "${_LINESWITCH[output]}" ]] && ADPN_JSON_TEMPLATE=$( printf -- "--template=%s" "${ADPN_STASH_SETTINGS}" ) || ADPN_JSON_TEMPLATE=""
				[[ -z "${_LINESWITCH[output]}" ]] && _LINESWITCH[output]="--output=text/plain"
				;;
			"close")
				if [[ -z "${_LINESWITCH[if-needed]}" || -n "${_PARAM[if-needed]}" ]] ; then
					declare -a ADPN_STASH_CLEANUP=() # FIXME: fill from log file
					for FILE in "${ADPN_STASH_FILE}" "${ADPN_STASH_CLEANUP[@]}" ; do
						[[ -z "${QQ}" ]] && RM="rm -v" || RM="rm"
						[[ -w "${FILE}" ]] && ${RM} "${FILE}" 1>&2
					done
					unset ADPN_STASH_JSON

					[[ -z "${_LINESWITCH[output]}" ]] && printf "unset ADPN_STASH_FILE;\nunset ADPN_STASH_KEY;\nunset ADPN_STASH_CLOSE;\n"
				fi
				;;
			""|"get")
				if [[ -n "${_PARAM[key]}" ]] ; then
					ADPN_SECRET_COUPLE_KEY="${_PARAM[key]}"
				else
					ADPN_SECRET_COUPLE_KEY="${ADPN_SECRETS_ARGS[0]}"
					ADPN_SECRETS_ARGS=( "${ADPN_SECRETS_ARGS[@]:1}" )
				fi

				ADPN_STASH_JSON="$( printf "%s\n" "${ADPN_STASH_KEY}" | adpn-do-stash.py --get )"
				EXITCODE="$?"

				;;
			"put")
				ADPN_STASH_OUTPUT="$( printf "%s\n%s" "${ADPN_STASH_KEY}" "${ADPN_SECRETS_ARGS[@]}" | adpn-json.py --cascade --output=application/json | adpn-do-stash.py --put )"
				
				ADPN_STASH_JSON="{}"
				if [[ -r "${ADPN_STASH_FILE}" ]] ; then
					ADPN_STASH_JSON="$( printf "%s" "${ADPN_STASH_KEY}" | adpn-do-stash.py --get )"
				fi
				;;
			"post")
				if [[ -n "${_PARAM[key]}" ]] ; then
					ADPN_SECRET_COUPLE_KEY="${_PARAM[key]}"
				else
					ADPN_SECRET_COUPLE_KEY="${ADPN_SECRETS_ARGS[0]}"
					ADPN_SECRETS_ARGS=( "${ADPN_SECRETS_ARGS[@]:1}" )
				fi
				if [[ -n "${_PARAM[value]}" ]] ; then
					ADPN_SECRET_COUPLE_VALUE="${_PARAM[value]}"
				else
					ADPN_SECRET_COUPLE_VALUE="${ADPN_SECRETS_ARGS[0]}"
					ADPN_SECRETS_ARGS=( "${ADPN_SECRETS_ARGS[@]:1}" )
				fi
				
				declare -a JSON_OVERLAYS=( "${ADPN_STASH_KEY}" )
				if [[ -r "${ADPN_STASH_FILE}" ]] ; then
					JSON_OVERLAYS+=( "$( printf "%s" "${ADPN_STASH_KEY}" | adpn-do-stash.py --get )" )
				fi
				JSON_OVERLAYS+=( "$( adpn-json.py --key="${ADPN_SECRET_COUPLE_KEY}" --value="${ADPN_SECRET_COUPLE_VALUE}" )" )
				
				ADPN_STASH_OUTPUT="$( printf '%s\n' "${JSON_OVERLAYS[@]}" | adpn-json.py --cascade --output=application/json | adpn-do-stash.py --put )"
				
				ADPN_STASH_JSON="{}"
				if [[ -r "${ADPN_STASH_FILE}" ]] ; then
					ADPN_STASH_JSON="$( printf '%s' "${ADPN_STASH_KEY}" | adpn-do-stash.py )"
				fi
				
				;;
			*)
				;;
		esac
		
		if [[ "${EXITCODE}" -gt 0 ]] ; then
			printf "[%s:%d] adpn-do-stash.py request FAILED: (req='%s', file='%s', error=%d)\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${WORD}" "${ADPN_STASH_FILE}" "${EXITCODE}" 1>&2
		elif [[ -n "${ADPN_STASH_JSON}" ]] ; then
			declare -a ADPN_JSON_ARGS=( )
			[[ -n "${ADPN_SECRET_COUPLE_KEY}" ]] && ADPN_JSON_ARGS+=( "--key=${ADPN_SECRET_COUPLE_KEY}" )
			[[ -n "${ADPN_JSON_TEMPLATE}" ]] && ADPN_JSON_ARGS+=( "${ADPN_JSON_TEMPLATE}" )
			[[ -n "${_LINESWITCH[output]}" ]] && ADPN_JSON_ARGS+=( "${_LINESWITCH[output]}" )
			printf "%s" "${ADPN_STASH_JSON}" | adpn-json.py "${ADPN_JSON_ARGS[@]}"
		fi
		;;

	"package")
# @method adpn package
# ADPNet Member: Package a directory of files into a LOCKSS Archival Unit (AU).
#
# Usage: adpn package [<LOCALPATH>] [<OPTIONS>]
#
# LOCALPATH is a directory on the local workstation containing the files for the
# Archival Unit (AU) to prepare.
#
# @version 2021.0715
		
		ADP_OUTPUT="$(mktemp)"
		
		declare -a ADP_ARGV=( "${_ARGV[@]:2}" )
		declare -A ADP_SWITCHES=( )
		for SWITCH in "${!_LINESWITCH[@]}" ; do
			case "${SWITCH}" in 
				"output")
					# DROP IT -- WE'LL SET IT OURSELVES BELOW
					;;
				*)
					ADP_SWITCHES[${SWITCH}]="${_LINESWITCH[$SWITCH]}"
					;;
			esac
		done
		
		adpn-do-package.py --output=application/json \
			"${ADP_ARGV[@]}" \
			"${ADP_SWITCHES[@]}" ${V} ${Q} ${DDBG} --context="${SCRIPT_CMD_NAME}"
		EXITCODE="$?"
		
		if [[ "${EXITCODE}" -lt 255 ]] ; then
			JSON_PACKET="$( adpn_select_json_packet "${ADP_OUTPUT}" )"
			printf "%s" "${JSON_PACKET}"
		fi
		
		rm "${ADP_OUTPUT}"
		;;
		
	"stage")
# @method adpn stage
# ADPNet Member: Stage AU files on the local workstation to the staging server.
#
# Usage: adpn stage [<LOCALPATH>] [<STAGING>] [<OPTIONS>]...
#
#   --subdirectory=<SLUG> 	destination subdirectory on staging server
#   --au_title=<TITLE>    	human-readable title of this AU
# 
# LOCALPATH is a directory on the local workstation containing the files for the
# Archival Unit (AU) to preserve. E.g.: "w:\WPA\Folder 01"
#
# STAGING is an URL specifying the FTP server and the path to the staging area to
# stage the AU files. E.g.: "sftp://adah@drop.adpn.org/adah/drop_au_content_in_here/"
# If omitted, content will be staged to the location provided by the stage/base
# configuration setting (@see adpn property get stage/base)
#
# @version 2021.0707

		ASC_OUTPUT="$(mktemp)"

		declare -a ASC_ARGV=( "${_ARGV[@]:2}" )
		declare -A ASC_SWITCHES=( )
		for SWITCH in "${!_LINESWITCH[@]}" ; do
			case "${SWITCH}" in 
				"output")
					# DROP IT -- WE'LL SET IT OURSELVES BELOW
					;;
				*)
					ASC_SWITCHES[${SWITCH}]="${_LINESWITCH[$SWITCH]}"
					;;
			esac
		done
		
		adpn-stage-content.py --output=application/json \
			"${ASC_SWITCHES[@]}" \
			"${ASC_ARGV[@]}" ${V} ${Q} ${DDBG} --context="${SCRIPT_CMD_NAME}" > "${ASC_OUTPUT}"
			ASC_ERRCODE="$?"
		
		if [[ "${ASC_ERRCODE}" -lt 255 ]] ; then
			JSON_PACKET="$( adpn_select_json_packet "${ASC_OUTPUT}" )"
			printf "%s" "${JSON_PACKET}"
		fi
		
		rm "${ASC_OUTPUT}"
		
		EXITCODE="${ASC_ERRCODE}"
		;;

	"notify")
# @method adpn notify
# ADPNet Member: Post a notification of a staged AU for the ADPNet Config Manager
# to accept from the staging server.
#
# Usage: printf "%s" "<JSON_INPUT>" | adpn notify [--from=<FROM>] [--subdirectory=<SLUG>]
#
#   --from=<FROM>        	ID of the staging area that this AU should be harvested from
#   --subdirectory=<DIR> 	AU subdirectory on staging server
#
# JSON_INPUT is the JSON-formatted metadata packet produced by a script command like
# `adpn stage` after packaging and staging the AU on an ADPNet staging server. E.g.:
#
# ~~~
# JSON PACKET: { "Ingest Title": "...", "File Size": "...", "From Peer": "ADAH", [...] }
# ~~~
#
# @version 2021.0709

		adpn-do-notify --from="${_PARAM[from]}" --subdirectory="${_PARAM[subdirectory]}" --context="${SCRIPT_CMD_NAME}" ${DDBG} ${V}
		EXITCODE="$?"
		;;
		
	"preserve")
# @method adpn preserve
# ADPNet Member: Stage AU files on the local workstation to the staging area,
# test connection to staging server, collect data, and verify plugin parameters;
# then generate JSON and notify network admin that content is ready to ingest.
#
# Usage: adpn preserve [<LOCALPATH>] [<STAGING>] [<OPTIONS>]...
#
#   --subdirectory=<SLUG> 	destination subdirectory on staging server
#   --au_title=<TITLE>    	human-readable title of this AU
#   --from=<PEER>         	code for origin node (AUB, ADAH, etc.)
#
# LOCALPATH is a directory on the local workstation containing the files for the
# Archival Unit (AU) to preserve. E.g.: "w:\WPA\Folder 01"
#
# STAGING is an URL specifying the FTP server and the path to the staging area to
# stage the AU files. E.g.: "sftp://adah@drop.adpn.org/adah/drop_au_content_in_here/"
# If omitted, content will be staged to the location provided by the stage/base
# configuration setting (@see adpn property get stage/base)
#
# Output: a report containing AU data, file size information, plugin parameters
# and a JSON packet for use by adpn ingest and adpn publish by Config Manager.
# Displayed to stdout; if adpn-do-notify can post a notification for the Config Manager
# this is filled in to the notification.
#
# @version 2021.0707

		declare -a AU_LOCALPATHS=( "${_ARGV[@]:2}" )
		AU_LOCALPATHS+=( "${PWD}" )
		AU_LOCALPATHS=( "${AU_LOCALPATHS[@]/#/\\}" )
		
		AU_LOCALPATH="$( adpn_parameter_from "--local" "${AU_LOCALPATHS[@]}" )"
		AU_LOCALPATH="$( readlink -f "${AU_LOCALPATH}" )"
		AU_LOCALBASE="$( basename "${AU_LOCALPATH}" )"
		
		[[ -n "${_PARAM[local]}" ]] && N=2 || N=3
		declare -a AU_STAGINGAREAS=( "${_ARGV[@]:$N}" )
		AU_STAGINGAREAS=( "${AU_STAGINGAREAS[@]/#/\\}" )
		STAGING_AREA="$( adpn_parameter_from "--remote" "${AU_STAGINGAREAS[@]}" ".stage/base" )"
		
		FROM="$( adpn_parameter_from "--from" "--publisher" "--peer" ".publisher"  ".peer" "<From (<PUBLISHER>): " )"
		SUBDIRECTORY="$( adpn_parameter_from "--subdirectory" "--directory" "<Directory name [${AU_LOCALBASE}]: " "${AU_LOCALBASE}")"
		DEFAULT_AU="$( printf "AU from %s" "${SUBDIRECTORY}" )"
		AU_TITLE="$( adpn_parameter_from "--au_title" "<AU Title [${DEFAULT_AU}]: " "\\${DEFAULT_AU}")"
		AU_INSTITUTION="$( adpn_parameter_from "--institution" ".institution" )"
		
		[[ -z "${V}" ]] || printf "[%s:%d] 1. Packaging files into LOCKSS Archival Unit (AU).\n" "${SCRIPT_CMD_NAME}" "${LINENO}"
		
		JSON_PACKET=$(
			"${ME}" package "${AU_LOCALPATH}" \
				--au_title="${AU_TITLE}" --subdirectory="${SUBDIRECTORY}" \
				${_LINESWITCH[skip]}
		) ; EXITCODE="$?"
		
		if [[ "${EXITCODE}" -gt 0 ]] ; then
			printf "[%s:%d] %s package FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT}" 1>&2
		else
			[[ -z "${V}" ]] || printf "[%s:%d] 2. Staging content to drop server.\n" "${SCRIPT_CMD_NAME}" "${LINENO}"
		
			JSON_PACKET=$(
				printf "%s" "${JSON_PACKET}" \
				| "${ME}" stage "${STAGING_AREA}" \
				--au_title="${AU_TITLE}" --subdirectory="${SUBDIRECTORY}" \
				${_LINESWITCH[skip]}
			) ; EXITCODE="$?"
		fi
		
		if [[ "${EXITCODE}" -gt 0 ]] ; then
			printf "[%s:%d] %s stage FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT}" 1>&2
		else 
			DROP_ID=$( adpn_parameter_from ".Staged To<${JSON_PACKET}" "\\${FROM}" )

			[[ -z "${V}" ]] || printf "[%s:%d] 3. Notifying ADPNet Tech of staged AU.\n" "${SCRIPT} ${CMD}" "${LINENO}"
			printf "%s" "${JSON_PACKET}" | ${SCRIPTPATH} notify --from="${DROP_ID}" --subdirectory="${SUBDIRECTORY}" --context="${SCRIPT_CMD_NAME}" ${DDBG} ${V} ; ADN_ERRCODE="$?"

			EXITCODE="${ADN_ERRCODE}"
		fi

		if [[ "${EXITCODE}" -gt 0 ]] ; then
			printf "[%s:%d] %s notify FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT}" 1>&2
		fi
		;;
	
	"verify")
# @method adpn verify
# Peer Manager, Config Manager: accept JSON data specifying a new AU for ingest
# test connection to the staging server and verify parameters
#
# Usage: adpn verify [-|<JSONFILE>] [<OPTIONS>]
#
# Options:
#    --from=<PUB> 	code for origin publisher (AUB, ADAH, etc.); overrides JSON data
#    --to=<PEER>   	node to publish to (AUB1, AUB2, ADAH, ...; ALL=entire network)
#    --peer=<PEER> 	synonym for --to=<PEER>
#
# @version 2021.0608

		if [[ -n "${_PARAM[pipeline]}" ]] ; then
			PIPELINE="${_LINESWITCH[pipeline]}"
			PIPEDFROMTO="${_PARAM[pipeline]}"
		else
			PIPEDFROMTO="staged:verified"
			PIPELINE="--pipeline=${PIPEDFROMTO}"
		fi
		if [[ -n "${PIPEDFROMTO}" ]] ; then
			PIPEDFROM=$( printf "%s" "${PIPEDFROMTO}" | cut --field=1 --delimiter=":" )
			PIPEDTO=$( printf "%s" "${PIPEDFROMTO}" | cut --field=2 --delimiter=":" )
			if [[ "${DBGLEVEL}" -ge 2 ]] ; then
				printf "SWITCH='%s', PIPELINE='%s': PIPEDFROM='%s', PIPEDTO='%s'\n" "${_LINESWITCH[pipeline]}" "${PIPEDFROMTO}" "${PIPEDFROM}" "${PIPEDTO}" 1>&2
			fi
		fi
		
		declare -a TEMP_CLEANUP=()

		AIT_PACKETS="$(mktemp)" ; TEMP_CLEANUP+=( "${AIT_PACKETS}" )
		AIT_INPUT="$(mktemp)" ; TEMP_CLEANUP+=( "${AIT_INPUT}" )
		AIT_OUTPUT="$(mktemp)" ; TEMP_CLEANUP+=( "${AIT_OUTPUT}" )

		adpn_get_json_packets "${_ARGV[2]}" "${ME}" "${SCRIPT} ${CMD}" "${V}" | adpn_select_json_packet > "${AIT_PACKETS}"
		EXITCODE="$?"
		
		if [[ -r "${AIT_PACKETS}" ]] ; then	
			# 1. Do we have a packet with "Ingest Step" = $PIPEDFROM? If so, prefer that one.
			if [[ -n "${DBG}" ]] ; then
				printf 'cat "%s" | adpn-json.py --output=application/json --where="Ingest Step:%s"\n' "${AIT_PACKETS}" "${PIPEDFROM}" 1>&2
			fi
			
			GREP=$( cat "${AIT_PACKETS}" | adpn-json.py --parse --output=application/json --where="Ingest Step:${PIPEDFROM}" )
			if [[ -n "${GREP}" ]] ; then
				printf "%s" "${GREP}" | head -n 1 > "${AIT_INPUT}"
			fi
			
			# 2. If not, let's take the FIRST packet that seems to be available. (verify=early)
			if [[ -z "${GREP}" ]] ; then
				if [[ -n "${DBG}" ]] ; then
					printf 'cat "%s" | adpn_select_json_packet | head -n 1\n' "${AIT_PACKETS}" 1>&2
				fi
				
				GREP=$( cat "${AIT_PACKETS}" | adpn_select_json_packet | head -n 1 )
				if [[ "${GREP}" ]] ; then
					printf "%s" "${GREP}" > "${AIT_INPUT}"
				fi
			fi
			
			if [[ "${DBGLEVEL}" -gt 1 ]] ; then
				printf "* DBG: JSON source (%s) = <<<EOF\n%s\nEOF;\n" "${AIT_INPUT}" "${GREP}" 1>&2
			fi
			
		fi
		
		if [[ -r "${AIT_INPUT}" ]] ; then
			PEER_TO=$( [[ -n "${_PARAM[to]}" ]] && printf "%s" "${_PARAM[to]}" || printf "%s" "${_PARAM[peer]}" )
			if [[ -z "${PEER_TO}" ]] ; then
				PEER_TO=$( adpnprop "peer" )
			fi
			if [[ -n "${PEER_TO}" ]] ; then
				PEER_TO=$( printf "%s--peer-to=%s" "" "${PEER_TO}" )
			fi

			if [[ -n "${DBG}" ]] ; then
				printf '[DBG] $ adpn-ingest-test "%s" --remote=1 "%s" "%s" %s %s > "%s"\n' "${AIT_INPUT}" "${PEER_TO}" "${PIPELINE}" "${V}" "${DDBG}" "${AIT_OUTPUT}" 1>&2 
			fi
		
			adpn-ingest-test "${AIT_INPUT}" --remote=1 "${PEER_TO}" "${PIPELINE}" ${V} ${DDBG} > "${AIT_OUTPUT}"
			EXITCODE="$?"

			cat "${AIT_OUTPUT}" ; echo
		fi
		
		for TMP in "${TEMP_CLEANUP[@]}" ; do
			rm "${TMP}"
		done

		if [[ "${EXITCODE}" -gt 0 ]] ; then
			printf "[%s:%d] adpn-ingest-test FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" 1>&2
		fi
		;;
		
	"accept"|"post"|"ingest")
# @method adpn accept
# Config Manager: accept JSON data specifying a new AU for ingest,
# test connection to the staging server and verify parameters; then
# insert into local titlesdb and confirm insertion.
#
# Usage: adpn accept [-|<JSONFILE>] [<OPTIONS>]...
#
# Options:
#   --from=<PEER>       	code for origin node (AUB, ADAH, etc.); overrides JSON data
#   --for=ALL|<PEER>     	node to publish to (AUB, ADAH...; ALL=entire network)
#   --to=ALL|<PEER>     	synonym for --for=<NODE>
#   --dry-run           	output SQL script for titlesdb insert but do not execute
#   --sqldump=<SQLFILE> 	output SQL script for titlesdb to this file
#
# @version 2021.0708

# @method adpn post
# Config Manager: synonym for `adpn accept`
#
# @version 2021.0708

# @method adpn ingest
# Config Manager: synonym for `adpn accept`
#
# @version 2021.0420

		AV_OUTPUT="$(mktemp)"
		
		PIPELINE="$( adpn_parameter_from "--pipeline" "verified:ingested" )"
		"${ME}" verify "${_CMDLINE[@]:2}" --pipeline="${PIPELINE}" > "${AV_OUTPUT}"
		EXITCODE="$?"

		cat "${AV_OUTPUT}" ; echo
		JSON_PACKET=$(grep "^JSON PACKET:" "${AV_OUTPUT}" | cut --fields=2-)
		
		rm "${AV_OUTPUT}"
		
		if [[ "${EXITCODE}" -gt 0 ]] ; then
			printf "[%s:%d] %s verify FAILED." "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT}" 1>&2
			
		else 
			
			INGEST_FROM="$( adpn_parameter_from "--from" ".From Peer<${JSON_PACKET}" "<From (<PEER>): " )"
			INGEST_TO="$( adpn_parameter_from "--for" "--to" "--peer" ".To Peer<${JSON_PACKET}" "<To (ALL|<PEER>): " )"
			
			adpn-titlesdb-diff --before "${INGEST_TO}" ${V}
			
			AIIT_OUTPUT="${_PARAM[sqldump]}"
			if [[ -z "${AIIT_OUTPUT}" ]] ; then
				[[ -z "${_PARAM[dry-run]}" ]] && AIIT_OUTPUT="/dev/null" || AIIT_OUTPUT="/dev/tty"
			fi
			
			adpn-ingest-into-titlesdb.py --snapshot
			printf "%s" "${JSON_PACKET}" | adpn-ingest-into-titlesdb.py --from="${INGEST_FROM}" --to="${INGEST_TO}" ${_LINESWITCH[dry-run]} > "${AIIT_OUTPUT}" ; EXITCODE="$?"
			
			if [[ "${EXITCODE}" -gt 0 ]] ; then
				printf "[%s:%d] adpn-ingest-into-titlesdb.py FAILED." "${SCRIPT_CMD_NAME}" "${LINENO}" 1>&2
			else
				adpn-titlesdb-diff --after "${INGEST_TO}" ${V} ; ATD_ERRCODE="$?"
				if [[ "${ATD_ERRCODE}" -gt 0 && -z "${_PARAM[dry-run]}"  ]] ; then
					printf "[%s:%d] adpn-titlesdb-diff FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" 1>&2
					EXITCODE="${ATD_ERRCODE}"
				elif [[ -z "${_PARAM[context]}" ]] ; then
					printf "\n[%s:%d] DONE: Archival Unit posted to %s titlesdb.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${INGEST_TO}" 1>&2
				fi
			fi
		fi
		;;
		
	"promote"|"publish")
# @method adpn promote
# Config Manager: accept JSON data specifying a new AU for ingest,
# test connection to the staging server and verify parameters; then
# insert into titlesdb for whole network and confirm insertion.
#
# Usage: adpn publish [-|<JSONFILE>] [<OPTIONS>]...
#
# Options:
#   --from=<PEER>       	code for origin node (AUB, ADAH, etc.); overrides JSON data
#   --dry-run           	output SQL script for titlesdb insert but do not execute
#   --sqldump=<SQLFILE> 	output SQL script for titlesdb to this file
#
# @version 2021.0420

# @method adpn publish
# Config Manager: synonym for `adpn promote`
#
# @version 2021.0420


		AI_OUTPUT="$(mktemp)"
		"${ME}" accept "${_CMDLINE[@]:2}" --for=ALL --pipeline=ingested:published --context="${SCRIPT} ${CMD}" > "${AI_OUTPUT}"
		AI_ERRCODE="$?"

		cat "${AI_OUTPUT}"
		JSON_PACKET=$(grep "^JSON PACKET:" "${AI_OUTPUT}" | cut --fields=2-)
		
		rm "${AI_OUTPUT}"

		if [[ "${AI_ERRCODE}" -gt 0 ]] ; then
			printf "[%s:%d] ${SCRIPT} accept FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT}" 1>&2
			EXITCODE="${AI_ERRCODE}"
		
		else
			printf "\n" 1>&2
			printf "[%s:%d] DONE: Archival Unit published to titlesdb.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" 1>&2

			TDB_XML=$( adpnprop "props/titlesdb.xml" )
			if [[ -r "${TDB_XML}" ]] ; then

				TDB_PATH=$( readlink -f "${TDB_XML}" )
				TDB_DIR=$( dirname "${TDB_PATH}" )
				TDB_FILE=$( basename "${TDB_PATH}" )
				
				printf "\n"
				printf "* Generating new static %s for network..." "${TDB_FILE}"

				cd "${TDB_DIR}"
				adpn-titlesdb-diff --before="${TDB_PATH}" --stype=1

				printf " (ok)\n"

				printf "* Comparing new %s to prior revision...\n\n"
				
				if [[ -z "${_PARAM[batch]}" ]] ; then
					git add --patch "${TDB_FILE}" < /dev/tty
				else
					git add "${TDB_FILE}"
				fi

				AU_TITLE=$(echo "${JSON_PACKET}" | adpn-json.py --key="Ingest Title")
				GC_MESSAGE=$( printf "Promoted new AU (%s)" "${AU_TITLE}" )

				git commit --message "${GC_MESSAGE}" 

			else 
			
				printf "[%s:%d] Warning: Could not locate static titlesDb XML file at [%s], so the new version was not generated.\n"  "${SCRIPT_CMD_NAME}" "${LINENO}" "${TDB_XML}" 1>&2
				
			fi
			
		fi
		;;

	"flag")
# @method adpn flag
# Config Manager: add or remove a parameter to an AU in titlesdb.
#
# Usage: adpn flag [-|<JSONFILE>] [<OPTIONS>]...
#
# Options:
#   --to=<PEER>     	code for destination feed (AUB, ADAH, etc.); overrides JSON data
#   --key=<KEY>     	key name for the parameter (crawl_proxy, pub_down, ...)
#   --value=<VALUE> 	value to set on the parameter (localhost:8080, true, ...)
#   --delete        	remove the parameter with this name
#   --dry-run       	output SQL script for titlesdb insert but do not execute
#
# @version 2021.0526

		if [[ -n "${_PARAM[pipeline]}" ]] ; then
			PIPELINE="${_LINESWITCH[pipeline]}"
			PIPEDFROMTO="${_PARAM[pipeline]}"
		else
			PIPEDFROMTO="published:flagged"
			PIPELINE="--pipeline=${PIPEDFROMTO}"
		fi
		if [[ -n "${PIPEDFROMTO}" ]] ; then
			PIPEDFROM=$( printf "%s" "${PIPEDFROMTO}" | cut --field=1 --delimiter=":" )
			PIPEDTO=$( printf "%s" "${PIPEDFROMTO}" | cut --field=2 --delimiter=":" )
			if [[ "${DBGLEVEL}" -ge 2 ]] ; then
				printf "SWITCH='%s', PIPELINE='%s': PIPEDFROM='%s', PIPEDTO='%s'\n" "${_LINESWITCH[pipeline]}" "${PIPEDFROMTO}" "${PIPEDFROM}" "${PIPEDTO}" 1>&2
			fi
		fi
		
		declare -a TEMP_CLEANUP=()

		AIIT_PACKETS="$(mktemp)" ; TEMP_CLEANUP+=( "${AIIT_PACKETS}" )
		AIIT_INPUT="$(mktemp)" ; TEMP_CLEANUP+=( "${AIIT_INPUT}" )
		
		adpn_get_json_packets "${_ARGV[2]}" "${ME}" "${SCRIPT} ${CMD}" "${V}" | adpn_select_json_packet > "${AIIT_PACKETS}"
		EXITCODE="$?"
		
		declare -a AF_PARAMS=( "${_ARGV[@]:3}" )
		if [[ -n "${_PARAM[key]}" ]] ; then
			AIIT_PARAM_KEY="${_PARAM[key]}"
		else
			AIIT_PARAM_KEY="${AF_PARAMS[0]}"
			AF_PARAMS=( "${AF_PARAMS[@]:1}" )
		fi
		if [[ -n "${_PARAM[value]}" ]] ; then
			AIIT_PARAM_VALUE="${_PARAM[value]}"
		else
			AIIT_PARAM_VALUE="${AF_PARAMS[0]}"
			AF_PARAMS=( "${AF_PARAMS[@]:1}" )
		fi
		AIIT_PARAM_OP="+"
		if [[ -n "${_PARAM[delete]}" ]] ; then
			AIIT_PARAM_OP="-"
		fi
		
		if [[ "${EXITCODE}" -eq 0 && -s "${AIIT_PACKETS}" ]] ; then
			# 1. Do we have a packet with "Ingest Step" = $PIPEDFROM? If so, prefer that one.
			if [[ -n "${DBG}" ]] ; then
				printf 'cat "%s" | adpn-json.py --output=application/json --where="Ingest Step:%s"\n' "${AIIT_PACKETS}" "${PIPEDFROM}" 1>&2
			fi
			
			GREP=$( cat "${AIIT_PACKETS}" | adpn-json.py --parse --output=application/json --where="Ingest Step:${PIPEDFROM}" )
			if [[ -n "${GREP}" ]] ; then
				printf "%s" "${GREP}" | tail -n 1 > "${AIIT_INPUT}"
			fi
			
			# 2. If not, let's take the LAST packet that seems to be available. (flag=late)
			if [[ -z "${GREP}" ]] ; then
				if [[ -n "${DBG}" ]] ; then
					printf 'cat "%s" | adpn_select_json_packet | tail -n 1\n' "${AIIT_PACKETS}" 1>&2
				fi
				
				GREP=$( cat "${AIIT_PACKETS}" | adpn_select_json_packet | tail -n 1 )
				if [[ "${GREP}" ]] ; then
					printf "%s" "${GREP}" > "${AIIT_INPUT}"
				fi
			fi
			
			if [[ "${DBGLEVEL}" -gt 1 ]] ; then
				printf "* DBG: JSON source (%s) = <<<EOF\n%s\nEOF;\n" "${AIIT_INPUT}" "${GREP}" 1>&2
			fi
			
		fi
		
		if [[ "${EXITCODE}" -eq 0 && -s "${AIIT_INPUT}" ]] ; then
			PEER_TO=$( [[ -n "${_PARAM[to]}" ]] && printf "%s" "${_PARAM[to]}" || printf "%s" "${_PARAM[peer]}" )
			FLAG_TO="${PEER_TO}"
			if [[ -z "${PEER_TO}" ]] ; then
				PEER_TO=$( adpnprop "peer" )
			fi
			if [[ -n "${PEER_TO}" ]] ; then
				PEER_TO=$( printf "%s--to=%s" "" "${PEER_TO}" )
			fi

			if [[ -n "${DBG}" ]] ; then
				printf '[DBG] $ adpn-ingest-into-titlesdb.py "%s" --remote=1 "%s" "%s" %s %s > "%s"\n' "${AIIT_INPUT}" "${PEER_TO}" "${PIPELINE}" "${V}" "${DDBG}" "${AIIT_OUTPUT}" 1>&2 
			fi

			AIIT_OUTPUT="${_PARAM[sqldump]}"
			if [[ -z "${AIIT_OUTPUT}" ]] ; then
				[[ -z "${_LINESWITCH[dry-run]}" ]] && AIIT_OUTPUT="/dev/null" || AIIT_OUTPUT="/dev/tty"
			fi

			adpn-titlesdb-diff --before "${FLAG_TO}" ${V}

			adpn-ingest-into-titlesdb.py "${AIIT_INPUT}" "${PEER_TO}" "${PIPELINE}" --parameter="${AIIT_PARAM_OP}${AIIT_PARAM_KEY}:${AIIT_PARAM_VALUE}" ${_LINESWITCH[dry-run]} ${V} ${DDBG} > "${AIIT_OUTPUT}"
			AIIT_ERRCODE="$?"
			
			if [[ "${AIIT_ERRCODE}" -gt 0 ]] ; then
				printf "[%s:%d] adpn-ingest-into-titlesdb.py FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" 1>&2
				EXITCODE="${AIIT_ERRCODE}"
			else
				adpn-titlesdb-diff --after "${FLAG_TO}" ${V} ; ATD_ERRCODE="$?"
				if [[ "${ATD_ERRCODE}" -gt 0 && -z "${_LINESWITCH[dry-run]}"  ]] ; then
					printf "[%s:%d] adpn-titlesdb-diff FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" 1>&2
					EXITCODE="${ATD_ERRCODE}"
				elif [[ -z "${_PARAM[context]}" ]] ; then
					printf "\n" 1>&2
					printf "[%s:%d] DONE: Archival Unit flagged with %s='%s' on %s titlesdb.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${AIIT_PARAM_KEY}" "${AIIT_PARAM_VALUE}" "${FLAG_TO}" 1>&2
				fi
			fi

		fi
		
		for TMP in "${TEMP_CLEANUP[@]}" ; do
			rm "${TMP}"
		done

		if [[ "${EXITCODE}" -gt 0 ]] ; then
			printf "[%s:%d] %s FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT} ${CMD}" 1>&2
		fi
		;;
		
	"gitlab")
		adpn-do-gitlab "${_CMDLINE[@]:2}" --context="${SCRIPT} ${CMD}" ; EXITCODE="$?"
		;;

	"serve")
# @method adpn serve
# Preservation Node Manager: Helps retrieve content preserved on a LOCKSS box.
#
# @version 2021.0319

		HTTP_USER=$( adpn_parameter_from "--daemon-user" ".daemon/user" )
		HTTP_PASS=$( adpn_parameter_from "--daemon-pass" ".daemon/pass" )
		if [[ -n "${HTTP_PASS}" ]] ; then
			HTTP_PASS="$( adpn_getpassword_from "${HTTP_PASS}" )"
		fi
		
		if [[ -z "${HTTP_USER}" ]] ; then
			read -p "LOCKSS Daemon User: " HTTP_USER
		fi
		if [[ -z "${HTTP_PASS}" ]] ; then
			read -sp "LOCKSS Daemon Password: " HTTP_PASS
		fi
		
		VERSION=1
		LOCKSS_BOX="$( adpn_parameter_from "--daemon" "localhost:8081" )"
		BASE_URL="$( adpn_parameter_from "--drop-server" ".stage/base_url" "http://drop.adpn.org/drop-server/adah/drop_au_content_in_here/" )"
		DIRECTORY="${_PARAM[directory]}"
		FILE="${_PARAM[file]}"
		
		FULL_URL=$( printf "%s%s/%s" "${BASE_URL}" "${DIRECTORY}" "${FILE}" )
		ENCODED_URL=$( rawurlencode "${FULL_URL}" )
		
		AU_ID_BASE='edu|auburn|adpn|directory|AuburnDirectoryPlugin&base_url~%s&directory~%s'
		AU_ID=$( printf "${AU_ID_BASE}" $(rawurlencode "${BASE_URL}" 2) $(rawurlencode "${DIRECTORY}" 2) )
		ENCODED_AU_ID=$( rawurlencode "${AU_ID}" )
		
		declare -a HT_PARAMS=()
		
		PARAM_URL="$( printf "url=%s" "${ENCODED_URL}" )"
		PARAM_AUID="$( printf "auid=%s" "${ENCODED_AU_ID}" )"
		PARAM_VERSION="$( printf "version=%d" "${VERSION}" )"
		
		HT_PARAMS+=( "${PARAM_URL}" )
		HT_PARAMS+=( "${PARAM_AUID}" )
		HT_PARAMS+=( "${PARAM_VERSION}" )
		
		HT_ARGS=$( join_by "&" "${HT_PARAMS[@]}" )

		OUTPUT_FILENAME="$( rawurlencode "${FILE}" )"
		wget "http://${LOCKSS_BOX}/ServeContent?${HT_ARGS}" --http-user="${HTTP_USER}" --http-password="${HTTP_PASS}" -O "${OUTPUT_FILENAME}"
		;;
			
	"rebalance")
# @method adpn rebalance
# Config Manager: Helps rebalance cached AUs on a LOCKSS cache.
#
# Usage:
# 
#   adpn rebalance
#   adpn rebalance script
#   adpn rebalance destination
#   adpn rebalance lockdown
#   adpn rebalance sync
#   adpn rebalance reregister
#
# @version 2021.0302

		adpn-do-rebalance "${_CMDLINE[@]:2}" --context="${SCRIPT} ${CMD}" ; EXITCODE="$?"
		;;

	"publisher")
# @method adpn publisher
# Config Manager: Helps review and manage the list of AU publishers on a LOCKSS props server.
#
# Usage:
# 
#   adpn publisher
#   adpn publisher list
#   adpn publisher add [<AU_PUB_ID>] [<PUBLISHER_NAME>]
#
# @version 2021.0302
		MYSQL_HOST="$( adpnprop 'mysql/host' )"
		SSH_REMOTE="$( adpnprop 'props-server/ssh' )"
		if [[ -n "${MYSQL_HOST}"  ]] ; then
			adpn-do-publisher --context="${SCRIPT} ${CMD}" "${_CMDLINE[@]:2}" ; EXITCODE="$?"
		elif [[ -n "${SSH_REMOTE}" ]] ; then
			adpn-do-publisher --remote="${SSH_REMOTE}" --context="${SCRIPT} ${CMD}" "${_CMDLINE[@]:2}" ; EXITCODE="$?"
		fi
		
		;;
	
	"plugins")
# @method adpn plugins
# List LOCKSS Publisher Plugins or display details for a selected Plugin.
# 
# Usage:
#   adpn plugins
#   adpn plugins list [<KEYWORDS>|/<REGEX>/|<GUID>|<JARURL>] [<OPTIONS>]...
#   adpn plugins details [<KEYWORDS>|/<REGEX>/|<GUID>|<JARURL>] [<OPTIONS>]...
#
# @version 2019.0716

		adpn-do-plugins --context="${SCRIPT} ${CMD}" "${_CMDLINE[@]:2}" ; EXITCODE="$?"
		;;
	
	"echo")
		declare -p _LINESWITCH
		declare -p _ARGV
		declare -p _PARAM
		;;
		
	*)
		printf "[%s:%d] '%s' command not understood.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT} ${CMD}" 1>&2
		printf "[%s:%d] %s\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${__HELP__}" 1>&2
		EXITCODE=255
		;;
esac

##########################################################################################
### CLEANUP: remove temporary output files and exit. #####################################
##########################################################################################

if [[ "${CMD}" != "stash" ]] ; then
	eval $( adpn stash close --if-needed="${ADPN_STASH_CLOSE}" --quiet )
fi

exit ${EXITCODE}
