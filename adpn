#!/bin/bash
#
# adpn: master script for scripted ADPNet operations.
#
# @version 2021.0820

SCRIPTPATH="$( which "$0" )"
SCRIPTPATH="$( readlink --canonicalize "${SCRIPTPATH}" )"
SCRIPTDIR="$( dirname "${SCRIPTPATH}" )"

source "${SCRIPTDIR}/adpn-define-aliases"

__USAGE__="Usage: ${SCRIPT} [--version] [--help] <CMD> [<ARGS>]"
__HELP__="Try '${SCRIPT} help' for more information."
__DOC__="""${__USAGE__}

  --version 	Display the version of the script
  --help    	Display these usage notes

The most commonly used ${SCRIPT} commands are:
  preserve  	ADPNet Member: prepare an AU for preservation and notify config manager
  verify    	Node Manager: accept an AU from Member, test, and confirm accessibility from your node
  accept    	Config Manager: accept a verified AU from Node, test, and insert into titlesdb
  promote   	Config Manager: publish an accepted Member's AU to the entire network
  help      	Display usage notes for the ${SCRIPT} script or for a given command
  
Exit codes:
0 = success (successful retrieval and expected result)
1-254 = error in executing command
255 = command not supported
"""

##########################################################################################
### COMMAND LINE: loop through switches ##################################################
##########################################################################################

shopt -s lastpipe

declare -a SWITCHFILES ; SWITCHFILES=()
if [[ -r "${CONFFILE}" ]] ; then
	SWITCHFILES+=(${CONFFILE})
fi

CMDLINETXT=$(mktemp)

declare -a _CMDLINE=("$0")
until [[ "$#" -lt 1 ]] ; do
	_CMDLINE+=("$1")
	printf "%s\n" "$1" >> "${CMDLINETXT}"
	shift
done

SWITCHFILES+=(${CMDLINETXT})

adpn_command_line "${SWITCHFILES[@]}"

rm "${CMDLINETXT}"

##########################################################################################
### SCRIPT: DETERMINE COMMAND & SHARED SETTINGS ##########################################
##########################################################################################

EXITCODE=0
CMD="${_ARGV[1]}"

adpn_set_display_settings # @see adpn-define-aliases

declare -a CONTEXT_SW=( "--context=${SCRIPT_CMD_NAME}" )
[[ -n "${DDBG}" ]] && CONTEXT_SW+=( "${DDBG}" )
[[ -n "${V}" ]] && CONTEXT_SW+=( "${V}" )
[[ -n "${Q}" ]] && CONTEXT_SW+=( "${Q}" )

if [[ ! -z "${_PARAM[version]}" ]] ; then
	if [[ -z "${CMD}" ]] ; then
		CMD="version"
	else
		"${ME}" version
	fi
fi

if [[ ! -z "${_PARAM[help]}" ]] ; then
	CMD="help"
	_ARGV=( "help" "${_ARGV[@]}" )
fi

adpn_debug 10,"${SCRIPT}","${CMD}",enter "${LINENO}" "entered, cmd=%s, cmdline='%s'" "${CMD}" "$( join_by "', '" "${_CMDLINE[@]:2}" )" 1>&2

##########################################################################################
## COMMUNICATIONS: check for information to access encrypted persistent data #############
##########################################################################################

export ADPN_STASH_FILE
export ADPN_STASH_KEY
ADPN_STASH_CLOSE=""

declare -A _NO_RECURSE=( [stash]=stash [setup]=stash [version]=stash [help]=stash )

if [[ stash =~ ^(${_NO_RECURSE[$CMD]})$ ]] ; then
	# avoid infinite recursion, double-execution, unwanted errors, etc.
	ADPN_STASH_JSON=""
elif [[ -z "${ADPN_STASH_FILE}" || -z "${ADPN_STASH_KEY}" ]] ; then
	# stash open: this will output some variable settings
	eval $( "${ME}" stash open --quiet --if-needed )
fi

##########################################################################################
### SCRIPT: EXECUTE PIPELINE  ############################################################
##########################################################################################

case "${CMD}" in
	"")
		adpn_notice "${LINENO}" "command expected (for example: '${SCRIPT} preserve', '${SCRIPT} accept', etc.)"
		adpn_notice "${LINENO}" "%s" "${__HELP__}"
		EXITCODE=255
		;;
		
	"version")
# @method adpn version
# Displays current version of the adpn script.
#
# Usage: adpn version
#
# @version 2019.0808
		VERSION=$(grep "^# @version" $0 | head --lines=1 | cut --only-delimited --fields=3- --delimiter=" ")
		printf "%s version %s\n" "${SCRIPT}" "${VERSION}"
		EXITCODE=0
		;;
		
	"help")
# @method adpn help
# Displays usage notes for the adpn script or a given adpn script command
#
# Usage: adpn help [<CMD>]
#
# CMD is an adpn script pipeline command, e.g. "preserve", "ingest", "publish"
# If omitted, display usage notes for the adpn script as a whole.
#
# @version 2019.0715
		HELPCMD="${_ARGV[2]}"
		if [[ -z "${HELPCMD}" ]] ; then
			echo "${__DOC__}"
			EXITCODE=0
		else 
			adpn_help_notes "${ME}" "${HELPCMD}" "${CMD}"
			EXITCODE=$?
		fi
		;;
		
	"test")
# @method adpn test 
#
# Usage: adpn test [<TESTCODE>] [<CMD>] [<ARGS>]...
#
# TESTCODE is a code identifying the test data packet to use. For a list of available
# tests, use:
#
# 	adpn test
#
# CMD is an adpn script pipeline command, e.g "preserve", "ingest", "publish"
# ARGS are the arguments for that pipeline command.
#
# @version 2019.0715

		TESTDIR="${SCRIPTDIR}/json/tests"
		if [[ "${_ARGV[2]}" =~ ^(adpnprop|adpn_parameter_from|adpn_getpassword_from|adpn_opened_get_labels|adpn_check_au_status|adpn_plugin_parameter_from_json)$ ]] ; then
			TEST_FUNCTION="${_ARGV[2]}"
			if [[ -n "${_PARAM[pipe]}" ]] ; then
				PIPED_INPUT="$( cat "-" )"
				SETTING_VALUE="$( printf "%s" "${PIPED_INPUT}" | "${TEST_FUNCTION}" "${_ARGV[@]:3}" )" ; EXITCODE="$?"
			else 
				SETTING_VALUE="$( "${TEST_FUNCTION}" "${_ARGV[@]:3}" )" ; EXITCODE="$?"
			fi
			adpn_notice "${LINENO}" "%s: exit=%d, value='%s'" "${TEST_FUNCTION}" "${EXITCODE}" "${SETTING_VALUE}"
		elif [[ ! -z "${_CMDLINE[2]}" ]] ; then
			TESTFILE=${TESTDIR}/${_CMDLINE[2]}.json
			if [[ -r "${TESTFILE}" ]] ; then
				"${_CMDLINE[0]}" "${_CMDLINE[@]:3}" ${TESTFILE}
				EXITCODE="$?"
			else
				printf "[%s:%d] Use '%s [<TESTCODE>]'.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT} ${CMD}" 1>&2
				printf "\n" 1>&2
				printf "Available tests:\n" 1>&2
				cd $TESTDIR && ls ./*.json | sed 's/^.\//- /' | sed 's/[.]json$//' 1>&2
				EXITCODE=255
			fi
		else
			printf "[%s:%d] Use '%s [<TESTCODE>]'.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT} ${CMD}" 1>&2
			printf "\n" 1>&2
			printf "Available tests:\n" 1>&2
			cd $TESTDIR && ls ./*.json | sed 's/^.\//- /' | sed 's/[.]json$//' 1>&2
			EXITCODE=255
		fi
		;;
	
	"setup")
# @method adpn setup
# Perform initial setup for adpn script in a new environment.
#
# Usage: adpn setup [<CMD>] [--for=<CONTEXT>]
#
#    --for=preserve 	sets up adpn for use on your workstation to submit AUs
#    --for=verify   	sets up adpn for use on your preservation node to verify AUs
#    --for=ingest  		sets up adpn for use on the props server to ingest/publish AUs
#    --for=publish  	synonym for --for=ingest
#   
# @version 2021.0406
		declare -a ADS_ARGV=()
		[[ -z "${_ARGV[2]}" ]] && ADS_ARGV+=( "all" ) || ADS_ARGV+=( "${_ARGV[@]:2}" )
		ADS_ARGV+=( "${_SWITCHES[@]}" )
		[[ -z "${_PARAM[context]}" ]] && ADS_ARGV+=( "--context=${SCRIPT_CMD_NAME}" )
		[[ -z "${_PARAM[script]}" ]] && ADS_ARGV+=( "--script=${SCRIPTPATH}" )
		
		adpn-do-setup "${ADS_ARGV[@]}" ; EXITCODE="$?"
		
		;;
		
	"property")
# @method adpn property
# Display property values from the configuration file (adpnet.json)
#
# Usage: adpn property [list|get <KEY>|set <KEY> <VALUE>]
#
# Example: adpn property get "peer"
#
# Output:
# * adpn property list # lists the available settings from the JSON hash table
# * adpn property get <KEY> # prints the value associated with <KEY> in the JSON hash table
# * adpn property set <KEY> <VALUE> # sets the value associated with <KEY> to <VALUE>
# 
# @version 2021.0406

		SUBCMD="${_ARGV[2]}"
		case "${SUBCMD}" in
			""|"list")
				adpnprop
				printf "\n"
				;;
			"get")
				adpnprop "${_ARGV[3]}"
				EXITCODE=$?
				;;
			"set")
				declare -a WORDS
				WORDS=( "${_ARGV[@]:3}" )
				if [[ -n "${_PARAM[key]}" ]] ; then
					KEY="${_PARAM[key]}"
				elif [[ -n "${WORDS[0]}" ]] ; then
					KEY="${WORDS[0]}"
					WORDS=( "${WORDS[@]:1}" )
				fi
				
				if [[ -n "${_PARAM[value]}" ]] ; then
					VALUE="${_PARAM[value]}"
				elif [[ -n "${WORDS[0]}" ]] ; then
					VALUE="${WORDS[0]}"
					WORDS=( "${WORDS[@]:1}" )
				fi
				
				APS_OUTPUT=$(mktemp)

				JSON_KEYVALUE="$( adpn-json.py --key="${KEY}" --value="${VALUE}" )"
				JSON_OTHERS="$( adpnprop --output=application/json )"
				printf "%s\n%s\n" "${JSON_OTHERS}" "${JSON_KEYVALUE}" | adpn-json.py --output="application/json;prettyprint" --cascade > "${APS_OUTPUT}"
				printf "\n" >> "${APS_OUTPUT}"

				JSONORIGINAL="$( readlink -f "${JSONCONFFILE}" )"
				JSONBACKUP="$( printf "%s~" "${JSONORIGINAL}" )"
				if [[ -r "${JSONORIGINAL}" ]] ; then
					cp "${JSONORIGINAL}" "${JSONBACKUP}"
				else
					printf "{}\n" > "${JSONBACKUP}"
				fi
				mv "${APS_OUTPUT}" "${JSONORIGINAL}"
				if [[ -z "${_PARAM[quiet]}" ]] ; then
					declare -a DIFF_SW=( "-u" )
					( diff --color /dev/null /dev/null 2>/dev/null ) && DIFF_SW+=( "--color" )
					diff "${DIFF_SW[@]}" "${JSONBACKUP}" "${JSONORIGINAL}"
				fi
				
				EXITCODE=0
				;;
			*)
				printf "[%s:%d] '%s' command not understood.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SUBCMD}" 1>&2
				EXITCODE=255
				;;
		esac
		;;
	
	"stash")
		WORD="$( printf "%s" "${_ARGV[2]}" | tr "[:upper:]" "[:lower:]" )"
		declare -a ADPN_SECRETS_ARGS=( "${_ARGV[@]:3}" )
		
		ADPN_SECRET_COUPLE_KEY=""
		ADPN_JSON_TEMPLATE=""
		case "${WORD}" in
			"open")
			
				declare -a ADPN_STASH_SETTINGS_SHELL=()
				ADPN_STASH_SETTINGS_SHELL+=( "export ADPN_STASH_FILE='%(file)s'" )
				ADPN_STASH_SETTINGS_SHELL+=( "export ADPN_STASH_KEY='%(\$json)s'" )

				if [[ -z "${_PARAM[if-needed]}" || -z "${ADPN_STASH_KEY}" || -z "${ADPN_STASH_FILE}" || ! -e "${ADPN_STASH_FILE}" ]] ; then
					ADPN_STASH_JSON="$( printf '%s\n' '{}' | adpn-do-stash.py --put )"

					ADPN_STASH_FILE="$( printf '%s' "${ADPN_STASH_JSON}" | adpn-json.py --key=file )"
					ADPN_STASH_KEY="$( printf '%s' "${ADPN_STASH_JSON}" )"
					[[ -z "${_PARAM[keep]}" ]] && ADPN_STASH_SETTINGS_SHELL+=( "ADPN_STASH_CLOSE='%(file)s'" )

				else 
					ADPN_STASH_KEY_JSON=$( printf "%s" "${ADPN_STASH_KEY}" )
					ADPN_STASH_FILE_JSON=$( printf '{"file": "%s"}' "${ADPN_STASH_FILE}" )
					ADPN_STASH_CACHED_JSON='{ "cached": 1 }'
					ADPN_STASH_JSON=$( printf '%s\n%s\n%s' "${ADPN_STASH_KEY_JSON}" "${ADPN_STASH_FILE_JSON}" "${ADPN_STASH_CACHED_JSON}" | adpn-json.py --cascade --output=application/json )
				fi

				[[ -z "${QQ}" ]] && ADPN_STASH_SETTINGS_SHELL+=( "declare -p ADPN_STASH_FILE 1>&2" )
				ADPN_STASH_SETTINGS="$( join_by "; " "${ADPN_STASH_SETTINGS_SHELL[@]}" )"
			
				[[ -z "${_SWITCHES[output]}" ]] && ADPN_JSON_TEMPLATE=$( printf -- "--template=%s" "${ADPN_STASH_SETTINGS}" ) || ADPN_JSON_TEMPLATE=""
				[[ -z "${_SWITCHES[output]}" ]] && _SWITCHES[output]="--output=text/plain"
				;;
			"close")
				if [[ -z "${_SWITCHES[if-needed]}" || -n "${_PARAM[if-needed]}" ]] ; then
					declare -a ADPN_STASH_CLEANUP=() # FIXME: fill from log file
					for FILE in "${ADPN_STASH_FILE}" "${ADPN_STASH_CLEANUP[@]}" ; do
						[[ -z "${QQ}" ]] && RM="rm -v" || RM="rm"
						[[ -w "${FILE}" ]] && ${RM} "${FILE}" 1>&2
					done
					unset ADPN_STASH_JSON

					[[ -z "${_SWITCHES[output]}" ]] && printf "unset ADPN_STASH_FILE;\nunset ADPN_STASH_KEY;\nunset ADPN_STASH_CLOSE;\n"
				fi
				;;
			""|"get")
				if [[ -n "${_PARAM[key]}" ]] ; then
					ADPN_SECRET_COUPLE_KEY="${_PARAM[key]}"
				else
					ADPN_SECRET_COUPLE_KEY="${ADPN_SECRETS_ARGS[0]}"
					ADPN_SECRETS_ARGS=( "${ADPN_SECRETS_ARGS[@]:1}" )
				fi

				ADPN_STASH_JSON="$( printf "%s\n" "${ADPN_STASH_KEY}" | adpn-do-stash.py --get )"
				EXITCODE="$?"

				;;
			"put")
				ADPN_STASH_OUTPUT="$( printf "%s\n%s" "${ADPN_STASH_KEY}" "${ADPN_SECRETS_ARGS[@]}" | adpn-json.py --cascade --output=application/json | adpn-do-stash.py --put )"
				
				ADPN_STASH_JSON="{}"
				if [[ -r "${ADPN_STASH_FILE}" ]] ; then
					ADPN_STASH_JSON="$( printf "%s" "${ADPN_STASH_KEY}" | adpn-do-stash.py --get )"
				fi
				;;
			"post")
				if [[ -n "${_PARAM[key]}" ]] ; then
					ADPN_SECRET_COUPLE_KEY="${_PARAM[key]}"
				else
					ADPN_SECRET_COUPLE_KEY="${ADPN_SECRETS_ARGS[0]}"
					ADPN_SECRETS_ARGS=( "${ADPN_SECRETS_ARGS[@]:1}" )
				fi
				if [[ -n "${_PARAM[value]}" ]] ; then
					ADPN_SECRET_COUPLE_VALUE="${_PARAM[value]}"
				elif [[ "${#ADPN_SECRETS_ARGS[@]}" -gt 0 ]] ; then
					ADPN_SECRET_COUPLE_VALUE="${ADPN_SECRETS_ARGS[0]}"
					ADPN_SECRETS_ARGS=( "${ADPN_SECRETS_ARGS[@]:1}" )
				elif [[ -n "${ADPN_SECRET_COUPLE_KEY}" ]] ; then
					ADPN_SECRET_COUPLE_VALUE="$( cat - )"
				fi
				
				declare -a JSON_OVERLAYS=( "${ADPN_STASH_KEY}" )
				if [[ -r "${ADPN_STASH_FILE}" ]] ; then
					JSON_OVERLAYS+=( "$( printf "%s" "${ADPN_STASH_KEY}" | adpn-do-stash.py --get )" )
				fi
				JSON_OVERLAYS+=( "$( adpn-json.py --key="${ADPN_SECRET_COUPLE_KEY}" --value="${ADPN_SECRET_COUPLE_VALUE}" )" )
				
				ADPN_STASH_OUTPUT="$( printf '%s\n' "${JSON_OVERLAYS[@]}" | adpn-json.py --cascade --output=application/json | adpn-do-stash.py --put )"
				
				ADPN_STASH_JSON="{}"
				if [[ -r "${ADPN_STASH_FILE}" ]] ; then
					ADPN_STASH_JSON="$( printf '%s' "${ADPN_STASH_KEY}" | adpn-do-stash.py )"
				fi
				
				;;
			*)
				;;
		esac
		
		if [[ "${EXITCODE}" -gt 0 ]] ; then
			printf "[%s:%d] adpn-do-stash.py request FAILED: (req='%s', file='%s', error=%d)\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${WORD}" "${ADPN_STASH_FILE}" "${EXITCODE}" 1>&2
		elif [[ -n "${ADPN_STASH_JSON}" ]] ; then
			declare -a ADPN_JSON_ARGS=( )
			[[ -n "${ADPN_SECRET_COUPLE_KEY}" ]] && ADPN_JSON_ARGS+=( "--key=${ADPN_SECRET_COUPLE_KEY}" )
			[[ -n "${ADPN_JSON_TEMPLATE}" ]] && ADPN_JSON_ARGS+=( "${ADPN_JSON_TEMPLATE}" )
			[[ -n "${_SWITCHES[output]}" ]] && ADPN_JSON_ARGS+=( "${_SWITCHES[output]}" )
			printf "%s" "${ADPN_STASH_JSON}" | adpn-json.py "${ADPN_JSON_ARGS[@]}"
		fi
		;;

	"package")
# @method adpn package
# ADPNet Member: Package a directory of files into a LOCKSS Archival Unit (AU).
#
# Usage: adpn package [<LOCALPATH>] [<OPTIONS>]
#
# LOCALPATH is a directory on the local workstation containing the files for the
# Archival Unit (AU) to prepare.
#
# @version 2021.0715
		
		ADP_OUTPUT="$(mktemp)"
		
		declare -a ADP_ARGV=( "${_ARGV[@]:2}" )
		declare -A ADP_SWITCHES=( )
		for SWITCH in "${!_SWITCHES[@]}" ; do
			case "${SWITCH}" in 
				"output")
					# DROP IT -- WE'LL SET IT OURSELVES BELOW
					;;
				*)
					ADP_SWITCHES[${SWITCH}]="${_SWITCHES[$SWITCH]}"
					;;
			esac
		done
		
		adpn-do-package.py --output=application/json \
			"${ADP_ARGV[@]}" \
			"${ADP_SWITCHES[@]}" "${CONTEXT_SW[@]}"
		EXITCODE="$?"
		
		if [[ "${EXITCODE}" -lt 255 ]] ; then
			JSON_PACKET="$( adpn_get_json_packets "${ADP_OUTPUT}" )"
			printf "%s" "${JSON_PACKET}"
		fi
		
		rm "${ADP_OUTPUT}"
		;;
		
	"stage")
# @method adpn stage
# ADPNet Member: Stage AU files on the local workstation to the staging server.
#
# Usage: adpn stage [<LOCALPATH>] [<STAGING>] [<OPTIONS>]...
#
#   --subdirectory=<SLUG> 	destination subdirectory on staging server
#   --au_title=<TITLE>    	human-readable title of this AU
# 
# LOCALPATH is a directory on the local workstation containing the files for the
# Archival Unit (AU) to preserve. E.g.: "w:\WPA\Folder 01"
#
# STAGING is an URL specifying the FTP server and the path to the staging area to
# stage the AU files. E.g.: "sftp://adah@drop.adpn.org/adah/drop_au_content_in_here/"
# If omitted, content will be staged to the location provided by the stage/base
# configuration setting (@see adpn property get stage/base)
#
# @version 2021.0707

		ASC_OUTPUT="$(mktemp)"

		declare -a ASC_ARGV=( "${_ARGV[@]:2}" )
		declare -A ASC_SWITCHES=( )
		for SWITCH in "${!_SWITCHES[@]}" ; do
			case "${SWITCH}" in 
				"output")
					# DROP IT -- WE'LL SET IT OURSELVES BELOW
					;;
				*)
					ASC_SWITCHES[${SWITCH}]="${_SWITCHES[$SWITCH]}"
					;;
			esac
		done
		
		adpn-stage-content.py --output=application/json \
			"${ASC_SWITCHES[@]}" \
			"${ASC_ARGV[@]}" "${CONTEXT_SW[@]}" > "${ASC_OUTPUT}"
			ASC_ERRCODE="$?"
		
		if [[ "${ASC_ERRCODE}" -lt 255 ]] ; then
			JSON_PACKET="$( adpn_get_json_packets "${ASC_OUTPUT}" )"
			printf "%s" "${JSON_PACKET}"
		fi
		
		rm "${ASC_OUTPUT}"
		
		EXITCODE="${ASC_ERRCODE}"
		;;
	
	"unstage")
# @method adpn unstage
# ADPNet Member: Unstage AU files from the staging server and replace with placeholder text
#
# Usage: adpn unstage [-|<JSONFILE>] [<OPTIONS>]...
#
# @version 2021.0817

		declare -A TEMPFILES=()
		TEMPFILES[STAGER_INPUT]="$( mktemp )"
		TEMPFILES[STAGER_OUTPUT]="$( mktemp )"
		TEMPFILES[STAGER_DIR]="$( mktemp -d )"
		
		adpn_read_json_packet_source "${_ARGV[2]}" "${ME}" "${SCRIPT} ${CMD}" "${V}" | adpn_get_json_packets | adpn_select_json_packet "staged" "-" "tail -n 1" > "${TEMPFILES[STAGER_INPUT]}"
		EXITCODE="$?"
		
		SUBDIRECTORY="$( adpn_parameter_from "--subdirectory" "--directory" )"
		[[ -z "${SUBDIRECTORY}" ]] && SUBDIRECTORY="$( cat "${TEMPFILES[STAGER_INPUT]}" | adpn_plugin_parameter_from_json "subdirectory" )"
		[[ -z "${SUBDIRECTORY}" ]] && SUBDIRECTORY="$( cat "${TEMPFILES[STAGER_INPUT]}" | adpn_plugin_parameter_from_json "directory" )"
		
		UNSTAGED_BY="$( adpn_get_user_email )"
		
		[[ -n "${V}" ]] && adpn_notice "${LINENO}" "Generating README.text for unstaged AU."
		README_TXT="$( cat "${TEMPFILES[STAGER_INPUT]}" | adpn-do-notify --step=unstaged --subdirectory="${SUBDIRECTORY}" "${CONTEXT_SW[@]}" --template:unstaged_by="${UNSTAGED_BY}" )"

		SUB_SUBDIRECTORY="$( printf "%s/%s" "${TEMPFILES[STAGER_DIR]}" "${SUBDIRECTORY}" )"
		mkdir -p "${SUB_SUBDIRECTORY}"
		printf "%s" "${README_TXT}" > "${SUB_SUBDIRECTORY}/README.text"

		adpn_debug 40,adpn,unstage "${LINENO}" "README.text contents: <<<EOF\n%s\nEOF;" "$( cat "${SUB_SUBDIRECTORY}/README.text" )"
		
		declare -a ASC_ARGV=( "${_ARGV[@]:3}" )
		declare -A ASC_SWITCHES=( )
		for SWITCH in "${!_SWITCHES[@]}" ; do
			case "${SWITCH}" in 
				"output"|"local")
					# DROP IT -- WE'LL SET IT OURSELVES BELOW
					;;
				*)
					ASC_SWITCHES[${SWITCH}]="${_SWITCHES[$SWITCH]}"
					;;
			esac
		done
		ASC_SWITCHES[--unstage]="--unstage"
		ASC_SWITCHES[--output]="--output=application/json"
		ASC_SWITCHES[--local]="$( printf -- "--local=%s" "${SUB_SUBDIRECTORY}" )"
		ASC_SWITCHES[--subdirectory]="--subdirectory=${SUBDIRECTORY}"

		[[ -n "${V}" ]] && adpn_notice "${LINENO}" "Unstaging files from staging area."
		
		cat "${TEMPFILES[STAGER_INPUT]}" | adpn-stage-content.py "${ASC_SWITCHES[@]}" \
			"${ASC_ARGV[@]}" "${CONTEXT_SW[@]}" > "${TEMPFILES[STAGER_OUTPUT]}"
			ASC_ERRCODE="$?"
		
		if [[ "${ASC_ERRCODE}" -lt 255 ]] ; then
			declare -a JSON_OVERLAYS=()
			JSON_OVERLAYS+=( "$( adpn_get_json_packets "${TEMPFILES[STAGER_OUTPUT]}" )" )
			JSON_PACKET="$( printf "%s\n" "${JSON_OVERLAYS[@]}" | adpn-json.py --cascade --output=application/json --prolog )"
			printf "\n%s\n" "${JSON_PACKET}"
		fi
		
		for TEMPFILE in "${TEMPFILES[@]}" ; do
			rm -r "${TEMPFILE}"
		done
		EXITCODE="${ASC_ERRCODE}"
		;;
	
	"notify")
# @method adpn notify
# ADPNet Member: Post a notification of a staged AU for the ADPNet Config Manager
# to accept from the staging server.
#
# Usage: printf "%s" "<JSON_INPUT>" | adpn notify [--from=<FROM>] [--subdirectory=<SLUG>]
#
#   --from=<FROM>        	ID of the staging area that this AU should be harvested from
#   --subdirectory=<DIR> 	AU subdirectory on staging server
#
# JSON_INPUT is the JSON-formatted metadata packet produced by a script command like
# `adpn stage` after packaging and staging the AU on an ADPNet staging server. E.g.:
#
# ~~~
# JSON PACKET: { "Ingest Title": "...", "File Size": "...", "From Peer": "ADAH", [...] }
# ~~~
#
# @version 2021.0709

		adpn-do-notify "${CONTEXT_SW[@]}" "${_CMD_REST[@]}"
		EXITCODE="$?"
		;;
	
	"preserve")
# @method adpn preserve
# ADPNet Member: Stage AU files on the local workstation to the staging area,
# test connection to staging server, collect data, and verify plugin parameters;
# then generate JSON and notify network admin that content is ready to ingest.
#
# Usage: adpn preserve [<LOCALPATH>] [<STAGING>] [<OPTIONS>]...
#
#   --subdirectory=<SLUG> 	destination subdirectory on staging server
#   --au_title=<TITLE>    	human-readable title of this AU
#   --from=<PEER>         	code for origin node (AUB, ADAH, etc.)
#
# LOCALPATH is a directory on the local workstation containing the files for the
# Archival Unit (AU) to preserve. E.g.: "w:\WPA\Folder 01"
#
# STAGING is an URL specifying the FTP server and the path to the staging area to
# stage the AU files. E.g.: "sftp://adah@drop.adpn.org/adah/drop_au_content_in_here/"
# If omitted, content will be staged to the location provided by the stage/base
# configuration setting (@see adpn property get stage/base)
#
# Output: a report containing AU data, file size information, plugin parameters
# and a JSON packet for use by adpn ingest and adpn publish by Config Manager.
# Displayed to stdout; if adpn-do-notify can post a notification for the Config Manager
# this is filled in to the notification.
#
# @version 2021.0707

		declare -a AU_LOCALPATHS=( "${_ARGV[@]:2}" )
		AU_LOCALPATHS+=( "${PWD}" )
		AU_LOCALPATHS=( "${AU_LOCALPATHS[@]/#/\\}" )
		
		AU_LOCALPATH="$( adpn_parameter_from "--local" "${AU_LOCALPATHS[@]}" )"
		AU_LOCALPATH="$( readlink -f "${AU_LOCALPATH}" )"
		AU_LOCALBASE="$( basename "${AU_LOCALPATH}" )"
		
		[[ -n "${_PARAM[local]}" ]] && N=2 || N=3
		declare -a AU_STAGINGAREAS=( "${_ARGV[@]:$N}" )
		AU_STAGINGAREAS=( "${AU_STAGINGAREAS[@]/#/\\}" )
		STAGING_AREA="$( adpn_parameter_from "--remote" "${AU_STAGINGAREAS[@]}" ".stage/base" )"
		
		FROM="$( adpn_parameter_from "--from" "--publisher" "--peer" ".publisher"  ".peer" "<From (<PUBLISHER>): " )"
		SUBDIRECTORY="$( adpn_parameter_from "--subdirectory" "--directory" "<Directory name [${AU_LOCALBASE}]: " "${AU_LOCALBASE}")"
		DEFAULT_AU="$( printf "AU from %s" "${SUBDIRECTORY}" )"
		AU_TITLE="$( adpn_parameter_from "--au_title" "<AU Title [${DEFAULT_AU}]: " "\\${DEFAULT_AU}")"
		AU_INSTITUTION="$( adpn_parameter_from "--institution" ".institution" )"
		
		[[ -z "${V}" ]] || adpn_notice "${LINENO}" "1. Packaging files into LOCKSS Archival Unit (AU)." 

		JSON_PACKET=$(
			"${ME}" package "${AU_LOCALPATH}" \
				--au_title="${AU_TITLE}" --subdirectory="${SUBDIRECTORY}" \
				${_SWITCHES[skip]} \
				"${CONTEXT_SW[@]}"
		) ; EXITCODE="$?"
		
		if [[ "${EXITCODE}" -gt 0 ]] ; then
			adpn_notice "${LINENO}" "%s package FAILED.\n" "${SCRIPT}"
		else
			[[ -z "${V}" ]] || adpn_notice "${LINENO}" "2. Staging content to drop server." 

			JSON_PACKET=$(
				printf "%s" "${JSON_PACKET}" \
				| "${ME}" stage "${STAGING_AREA}" \
				--au_title="${AU_TITLE}" --subdirectory="${SUBDIRECTORY}" \
				${_SWITCHES[skip]} \
				"${CONTEXT_SW[@]}"
			) ; EXITCODE="$?"
		fi
		
		if [[ "${EXITCODE}" -gt 0 ]] ; then
			adpn_notice "${LINENO}" "%s stage FAILED." "${SCRIPT}"
		else 
			DROP_ID=$( adpn_parameter_from ".Staged To<${JSON_PACKET}" "\\${FROM}" )

			[[ -z "${V}" ]] || adpn_notice "${LINENO}" "3. Notifying ADPNet Tech of staged AU."
			printf "%s" "${JSON_PACKET}" | "${SCRIPTPATH}" notify --from="${DROP_ID}" --subdirectory="${SUBDIRECTORY}" "${CONTEXT_SW[@]}" ; ADN_ERRCODE="$?"

			EXITCODE="${ADN_ERRCODE}"
		fi

		[[ "${EXITCODE}" -gt 0 ]] && adpn_notice "${LINENO}" "%s notify FAILED." "${SCRIPT}"
		;;
	
	"verify")
# @method adpn verify
# Peer Manager, Config Manager: accept JSON data specifying a new AU for ingest
# test connection to the staging server and verify parameters
#
# Usage: adpn verify [-|<JSONFILE>] [<OPTIONS>]
#
# Options:
#    --from=<PUB> 	code for origin publisher (AUB, ADAH, etc.); overrides JSON data
#    --to=<PEER>   	node to publish to (AUB1, AUB2, ADAH, ...; ALL=entire network)
#    --peer=<PEER> 	synonym for --to=<PEER>
#
# @version 2021.0807

		PIPELINE="$( adpn_parameter_from "--pipeline" "staged:verified" )"
		if [[ -n "${PIPELINE}" ]] ; then
			PIPEDFROM=$( printf "%s" "${PIPELINE}" | cut --field=1 --delimiter=":" )
			PIPEDTO=$( printf "%s" "${PIPELINE}" | cut --field=2 --delimiter=":" )
			adpn_debug 2 "${LINENO}" "SWITCH='%s', PIPELINE='%s': PIPEDFROM='%s', PIPEDTO='%s'\n" "${_SWITCHES[pipeline]}" "${PIPELINE}" "${PIPEDFROM}" "${PIPEDTO}" 1>&2
		fi
		
		declare -a TEMP_CLEANUP=()

		AIT_INPUT="$(mktemp)" ; TEMP_CLEANUP+=( "${AIT_INPUT}" )
		AIT_OUTPUT="$(mktemp)" ; TEMP_CLEANUP+=( "${AIT_OUTPUT}" )

		adpn_read_json_packet_source "${_ARGV[2]}" "${ME}" "${SCRIPT} ${CMD}" "${V}" | adpn_get_json_packets | adpn_select_json_packet "${PIPEDFROM}" "-" "head -n 1" > "${AIT_INPUT}"
		EXITCODE="$?"
		
		if [[ -r "${AIT_INPUT}" ]] ; then
			PEER_TO=$( [[ -n "${_PARAM[to]}" ]] && printf "%s" "${_PARAM[to]}" || printf "%s" "${_PARAM[peer]}" )
			if [[ -z "${PEER_TO}" ]] ; then
				PEER_TO=$( adpnprop "peer" )
			fi
			if [[ -n "${PEER_TO}" ]] ; then
				PEER_TO=$( printf "%s--peer-to=%s" "" "${PEER_TO}" )
			fi

			declare -a AIT_SW=( "--remote=1" )
			[[ -n "${PIPELINE}" ]] && AIT_SW+=( "--pipeline=${PIPELINE}" )
			[[ -n "$( adpn_get_user_email )" ]] && AIT_SW+=( "--by=$( adpn_get_user_email )" )
			[[ -n "${V}" ]] && AIT_SW+=( "${V}" )
			[[ -n "${DDBG}" ]] && AIT_SW+=( "${DDBG}" )
			
			adpn_debug 01 "${LINENO}" '$ adpn-ingest-test "%s" "%s" "%s" > "%s"\n' "${AIT_INPUT}" "${PEER_TO}" "$( join_by '" "' "${AIT_SW[@]}" )" "${AIT_OUTPUT}"
			adpn-ingest-test "${AIT_INPUT}" "${PEER_TO}" "${AIT_SW[@]}" > "${AIT_OUTPUT}" ; EXITCODE="$?"

			cat "${AIT_OUTPUT}" ; echo
		fi
		
		for TMP in "${TEMP_CLEANUP[@]}" ; do
			rm "${TMP}"
		done

		if [[ "${EXITCODE}" -gt 0 ]] ; then
			printf "[%s:%d] adpn-ingest-test FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" 1>&2
		fi
		;;
		
	"accept"|"post"|"ingest")
# @method adpn accept
# Config Manager: accept JSON data specifying a new AU for ingest,
# test connection to the staging server and verify parameters; then
# insert into local titlesdb and confirm insertion.
#
# Usage: adpn accept [-|<JSONFILE>] [<OPTIONS>]...
#
# Options:
#   --from=<PEER>       	code for origin node (AUB, ADAH, etc.); overrides JSON data
#   --for=ALL|<PEER>     	node to publish to (AUB, ADAH...; ALL=entire network)
#   --to=ALL|<PEER>     	synonym for --for=<NODE>
#   --dry-run           	output SQL script for titlesdb insert but do not execute
#   --sqldump=<SQLFILE> 	output SQL script for titlesdb to this file
#
# @version 2021.0708

# @method adpn post
# Config Manager: synonym for `adpn accept`
#
# @version 2021.0708

# @method adpn ingest
# Config Manager: synonym for `adpn accept`
#
# @version 2021.0420

		AV_OUTPUT="$(mktemp)" ; declare -a TEMP_CLEANUP=( "${AV_OUTPUT}" )
		
		PIPELINE="$( adpn_parameter_from "--pipeline" "verified:ingested" )"
		"${ME}" verify --pipeline="${PIPELINE}" "${_CMD_REST[@]}" > "${AV_OUTPUT}"
		EXITCODE="$?"

		cat "${AV_OUTPUT}" | grep -E -v "${ADPN_JSON_PACKET_REGEX}" ; echo
		JSON_PACKET=$(grep -E "${ADPN_JSON_PACKET_REGEX}" "${AV_OUTPUT}" | cut --fields=2-)
		
		if [[ "${EXITCODE}" -gt 0 ]] ; then
			printf "[%s:%d] %s verify FAILED." "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT}" 1>&2
			
		else 
			
			INGEST_FROM="$( adpn_parameter_from "--from" ".From Peer<${JSON_PACKET}" "<From (<PEER>): " )"
			INGEST_TO="$( adpn_parameter_from "--for" "--to" "--peer" ".To Peer<${JSON_PACKET}" "<To (ALL|<PEER>): " )"
			
			[[ -z "${_PARAM[dry-run]}" ]] && adpn-titlesdb-diff --before "${INGEST_TO}" ${V}
			
			AIIT_SQLOUT="${_PARAM[sqldump]}"
			if [[ -z "${AIIT_SQLOUT}" ]] ; then
				AIIT_SQLOUT="$( mktemp )" ; TEMP_CLEANUP+=( "${AIIT_SQLOUT}" )
			fi

			[[ -z "${_PARAM[dry-run]}" ]] && adpn-ingest-into-titlesdb.py --snapshot
			
			declare -a AIIT_CMDLINE=( "adpn-ingest-into-titlesdb.py" )
			AIIT_CMDLINE+=( "${CONTEXT_SW[@]}" )
			AIIT_CMDLINE+=( "--from=${INGEST_FROM}" "--to=${INGEST_TO}" )
			AIIT_CMDLINE+=( "--passthru" )
			[[ -n "${_SWITCHES[dry-run]}" ]] && AIIT_CMDLINE+=( "${_SWITCHES[dry-run]}" )
			[[ -n "${PIPELINE}" ]] && AIIT_CMDLINE+=( "--pipeline=${PIPELINE}" )

			printf "%s" "${JSON_PACKET}" | "${AIIT_CMDLINE[@]}" > "${AIIT_SQLOUT}" ; EXITCODE="$?"
			
			if [[ "${EXITCODE}" -gt 0 ]] ; then
				printf "[%s:%d] adpn-ingest-into-titlesdb.py FAILED." "${SCRIPT_CMD_NAME}" "${LINENO}" 1>&2
			else
				[[ -z "${_PARAM[dry-run]}" ]] && { adpn-titlesdb-diff --after "${INGEST_TO}" ${V} ; EXITCODE="$?" ; }
				if [[ "${EXITCODE}" -gt 0 ]] ; then
					printf "[%s:%d] adpn-titlesdb-diff FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" 1>&2
					EXITCODE="${ATD_ERRCODE}"
				else 
					if [[ -n "${_SWITCHES[dry-run]}" ]] ; then
						cat "${AIIT_SQLOUT}"
					else
						cat "${AIIT_SQLOUT}" | grep -E "${ADPN_JSON_PACKET_REGEX}"
					fi

					# Display final notice if this was called in its own right, not if by adpn promote &c.
					if [[ -z "${_PARAM[context]}" ]] ; then
						adpn_notice "${LINENO}" "DONE: Archival Unit posted to %s titlesdb." "${INGEST_TO}"
					fi
				fi
			fi
		fi
		
		for TMP in "${TEMP_CLEANUP[@]}" ; do
			rm "${TMP}"
		done
		;;
		
	"promote"|"publish")
# @method adpn promote
# Config Manager: accept JSON data specifying a new AU for ingest,
# test connection to the staging server and verify parameters; then
# insert into titlesdb for whole network and confirm insertion.
#
# Usage: adpn publish [-|<JSONFILE>] [<OPTIONS>]...
#
# Options:
#   --from=<PEER>       	code for origin node (AUB, ADAH, etc.); overrides JSON data
#   --dry-run           	output SQL script for titlesdb insert but do not execute
#   --sqldump=<SQLFILE> 	output SQL script for titlesdb to this file
#
# @version 2021.0420

# @method adpn publish
# Config Manager: synonym for `adpn promote`
#
# @version 2021.0420


		AI_OUTPUT="$(mktemp)"
		"${ME}" accept "${_CMDLINE[@]:2}" --for=ALL --pipeline=ingested:published --context="${SCRIPT} ${CMD}" > "${AI_OUTPUT}"
		AI_ERRCODE="$?"

		cat "${AI_OUTPUT}"
		JSON_PACKET=$(grep -E "${ADPN_JSON_PACKET_REGEX}" "${AI_OUTPUT}" | cut --fields=2-)
		
		rm "${AI_OUTPUT}"

		if [[ "${AI_ERRCODE}" -gt 0 ]] ; then
			printf "[%s:%d] ${SCRIPT} accept FAILED.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT}" 1>&2
			EXITCODE="${AI_ERRCODE}"
		
		else
			printf "\n" 1>&2
			printf "[%s:%d] DONE: Archival Unit published to titlesdb.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" 1>&2
			
			AU_TITLE="$( adpn_parameter_from "--au_title" ".Ingest Title<${JSON_PACKET}" )"

			declare -a AC_SW=()
			AC_SW+=( "$( printf -- "--message=Promoted new AU (%s)" "${AU_TITLE}" )" )
			[[ -n "${_PARAM[batch]}" ]] && AC_SW+=( "${_SWITCHES[batch]}" )
			
			"${ADPN}" commit "${AC_SW[@]}" "${CONTEXT_SW[@]}"
			EXITCODE="$?"
			
		fi
		;;
	
	"confirm")
# @method adpn confirm
# Node Manager: confirm the status of an ingested AU from the LOCKSS daemon
# 
# @version 2021.0812
		
		declare -a TEMP_CLEANUP=()

		PIPELINE="$( adpn_parameter_from "--pipeline" "published:unstaged" )"
		if [[ -n "${PIPELINE}" ]] ; then
			PIPEDFROM=$( printf "%s" "${PIPELINE}" | cut --field=1 --delimiter=":" )
			PIPEDTO=$( printf "%s" "${PIPELINE}" | cut --field=2 --delimiter=":" )
			adpn_debug 2 "${LINENO}" "SWITCH='%s', PIPELINE='%s': PIPEDFROM='%s', PIPEDTO='%s'\n" "${_SWITCHES[pipeline]}" "${PIPELINE}" "${PIPEDFROM}" "${PIPEDTO}" 1>&2
		fi

		DST_INPUT="$(mktemp)" ; TEMP_CLEANUP+=( "${DST_INPUT}" )
		DST_OUTPUT="$(mktemp)" ; TEMP_CLEANUP+=( "${DST_OUTPUT}" )
		
		adpn_read_json_packet_source "${_ARGV[2]}" "${ME}" "${SCRIPT} ${CMD}" "${V}" | adpn_get_json_packets | adpn_select_json_packet "${PIPEDFROM}" "-" "tail -n 1" > "${DST_INPUT}"
		EXITCODE="$?"

		if [[ -s "${DST_INPUT}" ]] ; then

			declare -a DST_SW=( "table" )
			
			adpn_debug 01 "${LINENO}" '$ cat "%s" | adpn_packet2daemonstatustable "%s" > "%s"\n' "${DST_INPUT}" "$( join_by '" "' "${AIT_SW[@]}" )" "${DST_OUTPUT}"
			LOCKSS_KEY="$( cat "${DST_INPUT}" | adpn_packet2lockssid )"
			cat "${DST_INPUT}" | adpn_packet2daemonstatustable "${DST_SW[@]}" > "${DST_OUTPUT}" ; EXITCODE="$?"

			declare -a DST_GREP_OPT=( "Volume" )
			[[ "${_PARAM[crawled]}" ]] && DST_GREP_OPT+=( "Disk Usage" "Status" "Last Completed Crawl" "Last Crawl" "Last Crawl Result" )
			[[ "${_PARAM[preserved]}" ]] && DST_GREP_OPT+=( "Disk Usage" "Status" "Last Completed Crawl" "Last Crawl Result" "Last Completed Poll" "Last Poll Result" )
			[[ "${_PARAM[down]}" ]] && DST_GREP_OPT+=( "Disk Usage" "Status" "Last Completed Crawl" "Last Crawl" "Last Crawl Result" "Available From Publisher" )
			[[ "${#_ARGV[@]}" -gt 3 ]] && DST_GREP_OPT+=( "${_ARGV[@]:3}" )
			[[ "${#DST_GREP_OPT[@]}" -le 1 ]] && DST_GREP_OPT+=( ".*" )
			
			DST_GREP="$( join_by "|" "${DST_GREP_OPT[@]}" )"
			
			if [[ -n "${_PARAM[preserved]}${_PARAM[crawled]}${_PARAM[down]}" ]] ; then
				grep -E "^(${DST_GREP})=" "${DST_OUTPUT}" | sed -E 's/\t/    /' | sed -E 's/^([^=]+)=(.*)$/\1\t\2/' | adpn_check_au_status "${_SWITCHES[@]}" ; EXITCODE="$?"
			elif [[ "${_PARAM[output]}" == "text/tab-separated-values" ]] ; then
				grep -E "^(${DST_GREP})=" "${DST_OUTPUT}" | sed -E 's/\t/    /' | sed -E 's/^([^=]+)=(.*)$/\1\t\2/'
			else
				grep -E "^(${DST_GREP})=" "${DST_OUTPUT}" ; echo
			fi
			
			if [[ "${EXITCODE}" -eq 0 && "${_PARAM[passthru]}" ]] ; then
				declare -a AC_TESTS=()
				[[ -n "${_PARAM[crawled]}" ]] && AC_TESTS+=( "crawled" )
				[[ -n "${_PARAM[preserved]}" ]] && AC_TESTS+=( "preserved" )
				[[ -n "${_PARAM[down]}" ]] && AC_TESTS+=( "down" )
				AC_S_TESTS="$( join_by "/" "${AC_TESTS[@]}" )"
				
				declare -a JSON_OVERLAYS=(
					"$( cat "${DST_INPUT}" )"
					"$( adpn-json.py --output=application/json --key="Ingest Step" --value="confirmed-${AC_S_TESTS}" --prolog )"
					"$( adpn-json.py --output=application/json --key="AU LOCKSS Key" --value="${LOCKSS_KEY}" --prolog )"
				)
				printf "\n"
				printf "%s\n" "${JSON_OVERLAYS[@]}" | adpn-json.py --cascade --output="application/json" --prolog
				printf "\n"
			
			fi
		fi
		
		for TMP in "${TEMP_CLEANUP[@]}" ; do
			rm "${TMP}"
		done

		[[ "${EXITCODE}" -gt 0 ]] && adpn_notice "${LINENO}" "adpn_packet2daemonstatustable FAILED." 
		;;
	"commit")
		TDB_XML=$( adpnprop "props/titlesdb.xml" )
		if [[ -r "${TDB_XML}" ]] ; then

			TDB_PATH=$( readlink -f "${TDB_XML}" )
			TDB_DIR=$( dirname "${TDB_PATH}" )
			TDB_FILE=$( basename "${TDB_PATH}" )
				
			printf "\n"
			printf "* Generating new static %s for network..." "${TDB_FILE}"

			cd "${TDB_DIR}"
			adpn-titlesdb-diff --before="${TDB_PATH}" --stype=1

			printf " (ok)\n"

			printf "* Comparing new %s to prior revision...\n\n"
				
			if [[ -z "${_PARAM[batch]}" ]] ; then
				git add --patch "${TDB_FILE}" < /dev/tty
			else
				git add "${TDB_FILE}"
			fi

			git commit --message "${_PARAM[message]}" 

		else 
			
			printf "[%s:%d] Warning: Could not locate static titlesDb XML file at [%s], so the new version was not generated.\n"  "${SCRIPT_CMD_NAME}" "${LINENO}" "${TDB_XML}" 1>&2
				
		fi
		;;
	"flag")
# @method adpn flag
# Config Manager: add or remove a parameter to an AU in titlesdb.
#
# Usage: adpn flag [-|<JSONFILE>] [<OPTIONS>]...
#
# Options:
#   --to=<PEER>     	code for destination feed (AUB, ADAH, etc.); overrides JSON data
#   --key=<KEY>     	key name for the parameter (crawl_proxy, pub_down, ...)
#   --value=<VALUE> 	value to set on the parameter (localhost:8080, true, ...)
#   --delete        	remove the parameter with this name
#   --dry-run       	output SQL script for titlesdb insert but do not execute
#
# @version 2021.0526

		MYSQL_HOST="$( adpnprop 'mysql/host' )"
		SSH_REMOTE="$( adpnprop 'props-server/ssh' )"
		if [[ -n "${MYSQL_HOST}"  ]] ; then
			adpn-do-flag --context="${SCRIPT} ${CMD}" "${_CMD_REST[@]}" ; EXITCODE="$?"
		elif [[ -n "${SSH_REMOTE}" ]] ; then
			adpn-do-flag --remote="${SSH_REMOTE}" --context="${SCRIPT} ${CMD}" "${_CMD_REST[@]}" ; EXITCODE="$?"
		fi
		;;
		
	"gitlab")
		adpn-do-gitlab "${_CMDLINE[@]:2}" --context="${SCRIPT} ${CMD}" ; EXITCODE="$?"
		;;
	
	"pipe")
		declare -a _CMD1=( "${ADPN}" "${CONTEXT_SW[@]}" "${_ARGV[@]:2}" )
		declare -a _CMDLINE1=( "${SCRIPT}" "${_ARGV[@]:2}" )
		declare -a _SUM1=( "${SCRIPT}" "${_ARGV[2]}" )
		
		declare -A TMPFILES=( [PIPE_OUT]="$( mktemp )" )
		
		AN_LABEL="$(adpn_parameter_from "--label" "<(${SCRIPT_CMD_NAME}) Issue Note Title (if any): " )"
		[[ -n "${AN_LABEL}" ]] && AN_LABEL="$( printf '**%s:** ' "${AN_LABEL%%+(:)}" )"
		AN_IN_ORDER_TO="$( adpn_parameter_from "--in-order-to" "<(${SCRIPT_CMD_NAME}) I'm using the '${_SUM1[*]}' command in order to: " )"
		[[ -n "${AN_IN_ORDER_TO}" ]] && AN_IN_ORDER_TO="$( printf ' to %s' "${AN_IN_ORDER_TO%%.}" )"

		PIPE_CMDLINE="$( printf "%q " "${_CMDLINE[@]}" )"
		declare -a AN_TEMPLATE=(
			'--step=output'
			'--template=output'
			"$( printf -- "--template:cmd=%s" "${_SUM1[*]}" )"
			"$( printf -- "--template:cmdline=%s" "${_CMDLINE1[*]}" )"
			"$( printf -- "--template:label=%s" "${AN_LABEL}" )"
			"$( printf -- "--template:executed_by=%s" "$( adpn_get_user_email )" )"
			"$( printf -- "--template:start_time=%s" "$( date )" )"
			"$( printf -- "--template:in_order_to=%s" "${AN_IN_ORDER_TO}" )"
			"$( printf -- "--template:pipe_cmdline=%s" "${PIPE_CMDLINE%%*( )}" )"
		)
		
		[[ -z "${QQ}" ]] && adpn_notice "${LINENO}" '$ %s' "${_CMDLINE1[*]}"
		adpn_debug 100,adpn,pipe,"${SUM1[1]}" "${LINENO}" 'exact$ %s %s' "${_CMD1[0]}" "$( printf "%q " "${_CMD1[@]:1}" )"
		if [[ -z "${Q}" ]] ; then
			"${_CMD1[@]}" | tee "${TMPFILES[PIPE_OUT]}"
			EXITCODE="${PIPESTATUS[0]}"
		else 
			"${_CMD1[@]}" > "${TMPFILES[PIPE_OUT]}"
			EXITCODE="$?"
		fi
		
		if [[ -n "${_PARAM[force]}" || "${EXITCODE}" -eq 0 ]] ; then
			[[ -z "${QQ}" ]] && adpn_notice "${LINENO}" '| %s | %s' "convertto_plain_text" "$( printf -- "%q " "${ME}" "notify" "${CONTEXT_SW[@]}" "${AN_TEMPLATE[@]}" )"
			cat "${TMPFILES[PIPE_OUT]}" | convertto_plain_text | "${ME}" notify "${CONTEXT_SW[@]}" "${AN_TEMPLATE[@]}"
			EXITCODE="$?"
		else
			[[ -n "${Q}" ]] && OUTPUT_NOTE=" Output below:" || OUTPUT_NOTE=""
			adpn_notice "${LINENO}" 'FAILED: piped command `%s` returned EXIT CODE %d.%s' "${_CMD1[*]}" "${EXITCODE}" "${OUTPUT_NOTE}"
			[[ -n "${OUTPUT_NOTE}" ]] && printf "~~~\n%s\n~~~\n" "$( cat "${TMPFILES[PIPE_OUT]}" )" 1>&2
		fi
		
		for FILE in "${TMPFILES[@]}" ; do
			rm "${FILE}"
		done
		;;
	"serve")
# @method adpn serve
# Preservation Node Manager: Helps retrieve content preserved on a LOCKSS box.
#
# @version 2021.0319

		HTTP_USER=$( adpn_parameter_from "--daemon-user" ".daemon/user" )
		HTTP_PASS=$( adpn_parameter_from "--daemon-pass" ".daemon/pass" )
		if [[ -n "${HTTP_PASS}" ]] ; then
			HTTP_PASS="$( adpn_getpassword_from "${HTTP_PASS}" )"
		fi
		
		if [[ -z "${HTTP_USER}" ]] ; then
			read -p "LOCKSS Daemon User: " HTTP_USER
		fi
		if [[ -z "${HTTP_PASS}" ]] ; then
			read -sp "LOCKSS Daemon Password: " HTTP_PASS
		fi
		
		VERSION=1
		LOCKSS_BOX="$( adpn_parameter_from "--daemon" "localhost:8081" )"
		BASE_URL="$( adpn_parameter_from "--drop-server" ".stage/base_url" "http://drop.adpn.org/drop-server/adah/drop_au_content_in_here/" )"
		DIRECTORY="${_PARAM[directory]}"
		FILE="${_PARAM[file]}"
		
		FULL_URL=$( printf "%s%s/%s" "${BASE_URL}" "${DIRECTORY}" "${FILE}" )
		ENCODED_URL=$( rawurlencode "${FULL_URL}" )
		
		AU_ID_BASE='edu|auburn|adpn|directory|AuburnDirectoryPlugin&base_url~%s&directory~%s'
		AU_ID=$( printf "${AU_ID_BASE}" $(rawurlencode "${BASE_URL}" 2) $(rawurlencode "${DIRECTORY}" 2) )
		ENCODED_AU_ID=$( rawurlencode "${AU_ID}" )
		
		declare -a HT_PARAMS=()
		
		PARAM_URL="$( printf "url=%s" "${ENCODED_URL}" )"
		PARAM_AUID="$( printf "auid=%s" "${ENCODED_AU_ID}" )"
		PARAM_VERSION="$( printf "version=%d" "${VERSION}" )"
		
		HT_PARAMS+=( "${PARAM_URL}" )
		HT_PARAMS+=( "${PARAM_AUID}" )
		HT_PARAMS+=( "${PARAM_VERSION}" )
		
		HT_ARGS=$( join_by "&" "${HT_PARAMS[@]}" )

		OUTPUT_FILENAME="$( rawurlencode "${FILE}" )"
		wget "http://${LOCKSS_BOX}/ServeContent?${HT_ARGS}" --http-user="${HTTP_USER}" --http-password="${HTTP_PASS}" -O "${OUTPUT_FILENAME}"
		;;
			
	"rebalance")
# @method adpn rebalance
# Config Manager: Helps rebalance cached AUs on a LOCKSS cache.
#
# Usage:
# 
#   adpn rebalance
#   adpn rebalance script
#   adpn rebalance destination
#   adpn rebalance lockdown
#   adpn rebalance sync
#   adpn rebalance reregister
#
# @version 2021.0302

		adpn-do-rebalance "${_CMDLINE[@]:2}" --context="${SCRIPT} ${CMD}" ; EXITCODE="$?"
		;;

	"publisher")
# @method adpn publisher
# Config Manager: Helps review and manage the list of AU publishers on a LOCKSS props server.
#
# Usage:
# 
#   adpn publisher
#   adpn publisher list
#   adpn publisher add [<AU_PUB_ID>] [<PUBLISHER_NAME>]
#
# @version 2021.0302
		MYSQL_HOST="$( adpnprop 'mysql/host' )"
		SSH_REMOTE="$( adpnprop 'props-server/ssh' )"
		if [[ -n "${MYSQL_HOST}"  ]] ; then
			adpn-do-publisher --context="${SCRIPT} ${CMD}" "${_CMDLINE[@]:2}" ; EXITCODE="$?"
		elif [[ -n "${SSH_REMOTE}" ]] ; then
			adpn-do-publisher --remote="${SSH_REMOTE}" --context="${SCRIPT} ${CMD}" "${_CMDLINE[@]:2}" ; EXITCODE="$?"
		fi
		
		;;
	
	"plugins")
# @method adpn plugins
# List LOCKSS Publisher Plugins or display details for a selected Plugin.
# 
# Usage:
#   adpn plugins
#   adpn plugins list [<KEYWORDS>|/<REGEX>/|<GUID>|<JARURL>] [<OPTIONS>]...
#   adpn plugins details [<KEYWORDS>|/<REGEX>/|<GUID>|<JARURL>] [<OPTIONS>]...
#
# @version 2019.0716

		adpn-do-plugins --context="${SCRIPT} ${CMD}" "${_CMDLINE[@]:2}" ; EXITCODE="$?"
		;;
	
	"echo")
		declare -p _SWITCHES
		declare -p _ARGV
		declare -p _PARAM
		;;
		
	*)
		printf "[%s:%d] '%s' command not understood.\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${SCRIPT} ${CMD}" 1>&2
		printf "[%s:%d] %s\n" "${SCRIPT_CMD_NAME}" "${LINENO}" "${__HELP__}" 1>&2
		EXITCODE=255
		;;
esac

##########################################################################################
### CLEANUP: remove temporary output files and exit. #####################################
##########################################################################################

if [[ stash =~ ^(${_NO_RECURSE[$CMD]})$ ]] ; then
	# avoid infinite recursion, double-execution, unwanted errors, etc.
	printf "NOOP" > /dev/null
else
	eval $( adpn stash close --if-needed="${ADPN_STASH_CLOSE}" --quiet )
fi

adpn_debug 10,"${SCRIPT}","${CMD}",exit "${LINENO}" "exited, cmd=%s, code=%d" "${CMD}" "${EXITCODE}"

exit ${EXITCODE}
