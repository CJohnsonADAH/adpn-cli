#!/bin/bash
#
# adpn-do-gitlab: script to handle Gitlab API commands
#
# @version 2021.0401

SCRIPTPATH="$(which "$0")"
SCRIPTPATH="$( readlink --canonicalize "${SCRIPTPATH}" )"
SCRIPTDIR="$(dirname "${SCRIPTPATH}")"
SCRIPT="$(basename "${SCRIPTPATH}")"
ME="${SCRIPTPATH}"

source "${SCRIPTDIR}/adpn-define-aliases"

__USAGE__="Usage: ${SCRIPT} [--version] [--help] <CMD> [<ARGS>]"
__HELP__="[${SCRIPT}] Try '${SCRIPT} help' for more information."
__DOC__="""${__USAGE__}

  --version 	Display the version of the script
  --help    	Display these usage notes

The most commonly used ${SCRIPT} commands are:
  issue  	Retrieve information about a Gitlab Issue thread
  
Exit codes:
0 = success (successful operation and expected result)
1-254 = error in executing command
255 = command not supported
"""

##########################################################################################
### COMMAND LINE: loop through switches ##################################################
##########################################################################################

declare -a _ARGV ; _ARGV=("$0")
declare -a _CMDLINE ; _CMDLINE=("$0")
declare -A _PARAM=()

shopt -s lastpipe

declare -a SWITCHFILES ; SWITCHFILES=()
if [[ -r "${CONFFILE}" ]] ; then
	SWITCHFILES+=(${CONFFILE})
fi

CMDLINETXT=$(mktemp)

until [[ "$#" -lt 1 ]] ; do
	_CMDLINE+=("$1")
	printf "%s\n" "$1" >> "${CMDLINETXT}"
	shift
done

SWITCHFILES+=(${CMDLINETXT})

adpn_command_line "${SWITCHFILES[@]}"

rm "${CMDLINETXT}"

##########################################################################################
### SCRIPT: DETERMINE COMMAND, THEN EXECUTE PIPELINE  ####################################
##########################################################################################

EXITCODE=0

VV="${_LINESWITCH[verbose]}"
QQ="${_LINESWITCH[quiet]}"
V="${_LINESWITCH[verbose]}"
Q=""

DBG="${_LINESWITCH[debug]}"
DBGLEVEL="${_PARAM[debug]}"
if [[ "${DBGLEVEL}" == "debug" ]] ; then
	DBGLEVEL=1
fi
if [[ "${DBGLEVEL}" -gt 1 ]] ; then
	DBGLEVEL=$(( DBGLEVEL - 1 ))
	DDBG="--debug=${DBGLEVEL}"
else
	DDBG=""
fi


if [[ -z "${_PARAM[verbose]}" ]] ; then
	Q="--quiet"
fi
if [[ -n "${QQ}" ]] ; then
	Q="--quiet"
fi

CMD="${_ARGV[1]}"

SCRIPT_CMD_NAME="${_PARAM[context]}"
if [[ -z "${SCRIPT_CMD_NAME}" ]] ; then
	SCRIPT_CMD_NAME="${SCRIPT}"
fi
if [[ -n "${CMD}" ]] ; then
	SCRIPT_CMD_NAME="${SCRIPT_CMD_NAME} ${CMD}"
fi

if [[ ! -z "${_PARAM[version]}" ]] ; then
	VERSION=$(grep "^# @version" $0 | head --lines=1 | cut --only-delimited --fields=3- --delimiter=" ")
	echo "${SCRIPT_CMD_NAME} version ${VERSION}"
	CMD="version"
fi

if [[ ! -z "${_PARAM[help]}" ]] ; then
	echo "${__DOC__}"
	CMD="help"
fi

if [[ "${CMD}" != "token" ]] ; then
	# Retrieve Gitlab token for ADPN script access to Gitlab
	# This may produce an interactive prompt for the master password on a kdbx file
	PRIVATE_TOKEN=$( "${ME}" token ${_LINESWITCH[token]} )
	
	# We should only have to retrieve this once, at the outset; pass it down to any child calls
	if [[ -n "${PRIVATE_TOKEN}" ]] ; then
		_LINESWITCH[token]="--token=${PRIVATE_TOKEN}"
		_PARAM[token]="${PRIVATE_TOKEN}"
	fi
fi

case "${CMD}" in
		
	""|"list"|"project")
# @method adpn gitlab list
# Display a list of available projects.
# 
# Usage: adpn gitlab list
#
# @version 2021.0331

		if [[ -z "${CMD}" ]] ; then
			CMD="list"
		fi
		
		if [[ -n "${_ARGV[*]:2}" ]] ; then
			PATH_REGEX=$( join_by "|" "${_ARGV[@]:2}" )
			REGEX="\bpath_with_namespace\s+(${PATH_REGEX})\b$"

			if [[ -n "${DBG}" ]] ; then
				echo "${SCRIPT}" get "/projects?membership=1" "|" adpn-json.py --parse --key=id:path_with_namespace "|" grep -E "${REGEX}" 1>&2
			fi
			
			"${ME}" get "/projects?membership=1" ${_LINESWITCH[token]} ${DDBG} | adpn-json.py --parse --key=id:path_with_namespace | grep -E "${REGEX}"
		else
			"${ME}" get "/projects?membership=1" ${_LINESWITCH[token]} ${DDBG} | adpn-json.py --parse --key=id:path_with_namespace
		fi
		EXITCODE="$?"
		;;

	"issue")
		METHOD=get
		declare -a ADPN_GITLAB_SW=("--fail")
		
		if [[ -n "${_PARAM[post]}" ]] ; then
			METHOD=post
			[[ -n "${_PARAM[dry-run]}" ]] && ADPN_GITLAB_SW+=("--dry-run")
			[[ -n "${_PARAM[title]}" ]] && ADPN_GITLAB_SW+=("--data-title=${_PARAM[title]}")
			[[ -n "${_PARAM[description]}" ]] && ADPN_GITLAB_SW+=("--data-description=${_PARAM[description]}")
			[[ -n "${_PARAM[labels]}" ]] && ADPN_GITLAB_SW+=("--data-labels=${_PARAM[description]}")
		fi
		
		API_PATH="/issues"
		
		[[ -n "${_PARAM[project]}" ]] && PROJECT="${_PARAM[project]}" || PROJECT="${_ARGV[2]}"

		ISSUE_ASPECT=$( printf "%s" "${PROJECT}" | cut --field=3 --delimiter='#' --only-delimited )
		ISSUE_ID=$( printf "%s" "${PROJECT}" | cut --field=2 --delimiter='#' --only-delimited )
		PROJECT=$( printf "%s" "${PROJECT}" | cut --field=1 --delimiter='#' )
		
		if [[ -n "${PROJECT}" ]] ; then
			PROJECT_ID=$( "${ME}" project "${PROJECT}" ${_LINESWITCH[token]} ${DDBG} | cut --field=2 )
		fi
		
		if [[ -n "${_ARGV[3]}" ]] ; then
			ISSUE_ID="${_ARGV[3]}"
		fi

		declare -a ADPN_JSON_SW=()
		
		[[ -n "${PROJECT_ID}" ]] && API_PATH=$( printf "/projects/%d%s" "${PROJECT_ID}" "${API_PATH}" )
		[[ -n "${ISSUE_ID}" ]] && API_PATH=$( printf "%s/%s" "${API_PATH}" "${ISSUE_ID}" )
		[[ -n "${ISSUE_ASPECT}" ]] && API_PATH=$( printf "%s/%s" "${API_PATH}" "${ISSUE_ASPECT}" )
		
		if [[ -n "${DBG}" ]] ; then
			printf "[${SCRIPT}] ISSUE ID: %s\n" "${ISSUE_ID}" 1>&2
			declare -p _ARGV 1>&2
		fi
		
		if [[ -n "${_PARAM[key]}" ]] ; then
			ADPN_JSON_SW+=( "--key=${_PARAM[key]}" )
		fi

		if [[ -n "${_PARAM[output]}" ]] ; then
			ADPN_JSON_SW+=( $(printf "%s--output=%s" "" "${_PARAM[output]}" ) )
		elif [[ -z "${_PARAM[key]}" ]] ; then
			ADPN_JSON_SW+=( "--output=urlencode" )
		fi
		
		F_JSON_OUT=$(mktemp)
		"${ME}" "${METHOD}" "${ADPN_GITLAB_SW[@]}" "${API_PATH}" ${_LINESWITCH[token]} ${V} ${DBG} > "${F_JSON_OUT}"
		EXITCODE="$?"

		if [[ "${_PARAM[output]}" =~ ^(application/)?json$ ]] ; then
			cat "${F_JSON_OUT}"
		elif [[ "${EXITCODE}" -eq 0 ]] ; then
			cat "${F_JSON_OUT}" | adpn-json.py --parse "${ADPN_JSON_SW[@]}"
			EXITCODE="$?"
		fi

		rm "${F_JSON_OUT}"
		;;

	"token")
		
		if [[ -n "${_PARAM[token]}" ]] ; then
			PRIVATE_TOKEN="${_PARAM[token]}"
		else
			PRIVATE_TOKEN=$( adpnprop "gitlab/token" )
			if [[ "${PRIVATE_TOKEN}" =~ ^keepass:/*(/.*)$ ]] ; then
				KDBX_FILE="${BASH_REMATCH[1]}"
				if [[ -r "${KDBX_FILE}" ]] ; then
					if [[ -n "${V}" ]] ; then
						printf "* Getting Gitlab token from KeePass repository %s\n" "${BASH_REMATCH[1]}" 1>&2
					fi
					PRIVATE_TOKEN=$( adpn-get-keepass.py --database="${BASH_REMATCH[1]}" --regex="^(adpn-)?gitlab-token" )
				else
					printf "* ERROR: Tried to find Gitlab token from KeePass repository %s - NOT READABLE\n" "${BASH_REMATCH[1]}" 1>&2
					EXITCODE=1
				fi
			fi
		fi
		printf "%s" "${PRIVATE_TOKEN}"
		;;
	
	"packet")
		
		F_GL_ISSUE=$(mktemp)
		ERR_DATA=""
				
		ISH="${_ARGV[2]}"
		if [[ -n "${DBG}" ]] ; then
			echo "${SCRIPT}" issue "${ISH}" "${_ARGV[@]:3}" --key=id:title:description --output="multipart/form-data;table" ">" "${F_GL_ISSUE}" 1>&2
		fi
		
		"${ME}" issue "${ISH}" "${_ARGV[@]:3}" --key=id:title:description --output="multipart/form-data;table" ${_LINESWITCH[token]} ${DDBG} > "${F_GL_ISSUE}" ; EXITCODE="$?"
		
		RE_PACKET="^JSON\s+PACKET:\s*"
		
		if [[ "${EXITCODE}" -eq 0 ]] ; then
			ALL_GREPS=1 # assume failure until we find a match
			
			# 1. Scan for the JSON packet, if any, in issue.description
			IFS=""
			cat "${F_GL_ISSUE}" | while read -r LINE ; do

				ISSUE_ID=$( echo "${LINE}" | cut --field=2 )
				ENCTITLE=$( echo "${LINE}" | cut --field=4 )
				ENCBODY=$( echo "${LINE}" | cut --field=6 )
				
				ISH_TITLE=$( urldecode "${ENCTITLE}" )
				ISH_BODY=$( urldecode "${ENCBODY}" )

				printf "%s" "${ISH_BODY}" | grep -E "${RE_PACKET}"
				GREPEXIT="$?"
				
				# if not found, retain some data for possible error message
				if [[ "${GREPEXIT}" -ge 0 ]] ; then
					ERR_DATA=$( printf "%s [title: '%s']" "${ERR_DATA}" "${ISH_TITLE}" )
				fi
				
				# if found, flag this as OK
				if [[ "${GREPEXIT}" -lt "${ALL_GREPS}" ]] ; then
					ALL_GREPS="${GREPEXIT}"
				fi

			done
		
			# 2. Scan for the JSON packet, if any, in issue/notes.body
			ISHN="${ISH}#notes?sort=asc&order_by=created_at"
			"${ME}" issue "${ISHN}" "${_ARGV[@]:3}" --key=id:body --output=urlencode ${_LINESWITCH[token]} > "${F_GL_ISSUE}"
			EXITCODE="$?"
			
			if [[ "${EXITCODE}" -eq 0 ]] ; then
				IFS=""
				cat "${F_GL_ISSUE}" | while read -r LINE ; do
					NOTE_ID=$( echo "${LINE}" | cut --field=2 )
					ENCBODY=$( echo "${LINE}" | cut --field=4 )
					BODY=$( urldecode "${ENCBODY}" )
					GREP=$( printf "%s" "${BODY}" | grep -E "${RE_PACKET}" )
					GREPEXIT="$?"

					if [[ -n "${GREP}" ]] ; then
						printf "%s\n" "${GREP}"
					fi
					
					# if found, flag this as OK
					if [[ "${GREPEXIT}" -lt "${ALL_GREPS}" ]] ; then
						ALL_GREPS="${GREPEXIT}"
					fi
				done
				EXITCODE="${ALL_GREPS}"
			fi
		fi
		
		if [[ "${EXITCODE}" -gt 0 ]] ; then
			if [[ -z "${QQ}" ]] ; then
				printf "[%s] No JSON packet found for issue %s%s\n" "${SCRIPT_CMD_NAME}" "${ISH}" "${ERR_DATA}" 1>&2
			fi
		fi
		
		rm -f "${F_GL_ISSUE}"
		;;
		
	"get")

		OBJECT="${_CMDLINE[2]}"
		if [[ "${OBJECT}" == "packet" ]] ; then
		# Treat this as a request for a JSON packet encoded within a given Gitlab Issue
		
			"${ME}" packet "${_CMDLINE[@]:3}" ${_LINESWITCH[token]} ; EXITCODE="$?"
			
		elif [[ "${OBJECT}" == "issue" ]] ; then
		# Treat this as a request for a Gitlab Issue object from the Gitlab API / refs <https://docs.gitlab.com/ee/api/issues.html>
			
			"${ME}" issue "${_CMDLINE[@]:3}" ${_LINESWITCH[token]} ; EXITCODE="$?"
			
		elif [[ "${OBJECT}" == "project" ]] ; then
		# Treat this as a request for a Gitlab Project object from the Gitlab API / refs <https://docs.gitlab.com/ee/api/projects.html>
			
			"${ME}" project "${_CMDLINE[@]:3}" ${_LINESWITCH[token]} ; EXITCODE="$?"
			
		elif [[ "${OBJECT}" == "token" ]] ; then
		# Treat this as a request for the Gitlab private access token as stored in adpnet.json or the encrypted KeePass database
			
			"${ME}" token "${_CMDLINE[@]:3}" ${_LINESWITCH[token]} ; EXITCODE="$?"
			
		else 
		# Treat this as one or more direct requests to the Gitlab API / refs <https://docs.gitlab.com/ee/api/README.html>

			if [[ -z "${PRIVATE_TOKEN}" ]] ; then
				printf "[%s] WARNING: Use of the Gitlab API requires an access token, and you don't seem to have one configured. See <https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html>\n" "${SCRIPT_CMD_NAME}" 1>&2
			else 
			
				API_URL=$( adpnprop "gitlab/base" )
				if [[ -n "${_PARAM[url]}" ]] ; then
					API_URL="${_PARAM[url]}"
				fi
		
				declare -a CURL_SW=()
				CURL_SW+=( "--silent" )
				CURL_SW+=( "--request" "GET" )
				if [[ -n "${_PARAM[fail]}" ]] ; then
					CURL_SW+=( "--fail" )
				fi
				if [[ -n "${PRIVATE_TOKEN}" ]] ; then
					CURL_SW+=( "--header" )
					CURL_SW+=( "PRIVATE-TOKEN: ${PRIVATE_TOKEN}"  )
				fi
				
				for SLUG in "${_ARGV[@]:2}" ; do
					URL=$( printf "${API_URL}" "${SLUG#/}" )
					if [[ -n "${DBG}" ]] ; then
						echo "DBG:" curl "${CURL_SW[@]}" "${URL}" 1>&2
					fi
					curl "${CURL_SW[@]}" "${URL}"

					CURLEXIT="$?"
					if [[ "${CURLEXIT}" -ge "${EXITCODE}" ]] ; then
						EXITCODE="${CURLEXIT}"
					fi
				done
			fi
		fi
		;;
	
	"post")
		if [[ -z "${PRIVATE_TOKEN}" ]] ; then
			printf "[%s] WARNING: Use of the Gitlab API requires an access token, and you don't seem to have one configured. See <https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html>\n" "${SCRIPT_CMD_NAME}" 1>&2
		else 
			
			API_URL=$( adpnprop "gitlab/base" )
			if [[ -n "${_PARAM[url]}" ]] ; then
				API_URL="${_PARAM[url]}"
			fi
		
			declare -a CURL_SW=()
			CURL_SW+=( "--silent" )
			CURL_SW+=( "--request" "POST" )
			if [[ -n "${_PARAM[fail]}" ]] ; then
				CURL_SW+=( "--fail" )
			fi
			if [[ -n "${PRIVATE_TOKEN}" ]] ; then
				CURL_SW+=( "--header" )
				CURL_SW+=( "PRIVATE-TOKEN: ${PRIVATE_TOKEN}"  )
			fi
			
			for KEY in "${!_PARAM[@]}" ; do 
				case "${KEY}" in 
				"token"|"context"|"verbose"|"quiet"|"debug"|"dry-run")
					;;
				"fail")
					;;
				*)
					FIELD="${KEY}"
					if [[ "${KEY}" =~ ^data-(.*) ]] ; then
						FIELD="${BASH_REMATCH[1]}"
					fi
					CURL_SW+=( "--data-urlencode" "${FIELD}=${_PARAM[$KEY]}" )
					;;
				esac
			done
			
			for SLUG in "${_ARGV[@]:2}" ; do
				URL=$( printf "${API_URL}" "${SLUG#/}" )
				if [[ -n "${DBG}" ]] ; then
					echo "DBG:" curl "${CURL_SW[@]}" "${URL}" 1>&2
				fi
				if [[ -z "${_PARAM[dry-run]}" ]] ; then
					curl "${CURL_SW[@]}" "${URL}"
				fi
				
				CURLEXIT="$?"
				if [[ "${CURLEXIT}" -ge "${EXITCODE}" ]] ; then
					EXITCODE="${CURLEXIT}"
				fi
			done
		fi
		;;
		
	"parse")
		GITLAB_ISSUE=""
		for PACKET_SOURCE in "${_ARGV[@]:2}" ; do

			if [[ "${PACKET_SOURCE}" =~ ^gitlab:(.*)$ ]] ; then
				GITLAB_ISSUE="${BASH_REMATCH[1]}"
			elif [[ "${PACKET_SOURCE}" =~ ^(([A-Za-z0-9/]|-)+)[#]([0-9]+)$ ]] ; then
				GITLAB_ISSUE="${BASH_REMATCH[0]}"
			elif [[ "${PACKET_SOURCE}" =~ ^[#]?([0-9]+)$ ]] ; then
				DEFAULT_REPOSITORY="$( adpnprop gitlab/repository )"
				GITLAB_ISSUE="$( printf "%s#%d" "${DEFAULT_REPOSITORY}" "${BASH_REMATCH[1]}" )"
			elif [[ "${PACKET_SOURCE}" =~ ^((https?[:])?//(www[.])?gitlab[.]com/(([a-zA-Z0-9/]|-)+)(/-)(/issues/([0-9]+)))$ ]] ; then
				GITLAB_ISSUE="$( printf "%s#%d" "${BASH_REMATCH[4]}" "${BASH_REMATCH[8]}" )"
			fi
		
			if [[ -n "${GITLAB_ISSUE}" ]] ; then
				if [[ "${_PARAM[output]}" == "tsv" ]] ; then
					PROJECT_ID="$( printf "%s" "${GITLAB_ISSUE}" | cut --field=1 --delimiter="#" )"
					ISSUE_ID="$( printf "%s" "${GITLAB_ISSUE}" | cut --field=2 --delimiter "#" --only-delimited )"
					printf "%s\t%s\n" "${PROJECT_ID}" "${ISSUE_ID}"
				else
					printf "%s" "${GITLAB_ISSUE}"
				fi
				
			else
				if [[ "${DBGLEVEL}" -ge 2 ]] ; then
					printf "[%s] Unable to recognize and parse a Gitlab issue ID from: '%s'\n" "${SCRIPT} ${CMD}" "${PACKET_SOURCE}"
					EXITCODE=1
				fi
			fi
		
		done
		;;
		
	"version"|"help")
		EXITCODE=0
		;;
		
	*)
		echo "[${SCRIPT_CMD_NAME}] '${CMD}' command not understood." 1>&2
		echo "${__HELP__}" 1>&2
		EXITCODE=255
		;;
esac

##########################################################################################
### CLEANUP: remove temporary output file. ###############################################
##########################################################################################

exit ${EXITCODE}
